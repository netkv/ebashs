#!/bin/bash
printf '\e[?1049h'
# Spis: text editor written in pure bash powered by murky logic and mess
shopt -s lastpipe # For syntax
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize; (:;:) # Enable and then trigger a terminal size refresh
trap redrawa WINCH ALRM # Attach WINCH and ALRM to redraw the screen
trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
trap quit INT
trap quit SIGTERM

declare -A syntax menufile menulineedit menuhelp menukey menudebug style windowkey options charmap menufancy commands filepickmenu menulineabout
declare -A keys_def keys_edit keys_command keys_interact keys_view keys_menu
declare -A key_options_menu
declare -a buffer buffersyntax bufferexpand hexkey overlay
declare -i line base rl menulinep menulinepy fll toplines bottomlines hidden offx offy sizx sizy update ismenu
declare -n menucon menuline
declare file message info modified filetype comment rst mode command cmd_prompt help_message


### Config options
## General options
options=(
	[mouse]=false
	[todonote]=true
	[menuline]=true
	[defx]=$(( sizx / 2 ))
	[defy]=$(( sizy /2 ))
	[timeout]=0.01
	[tabchar]='‚îÇ   '
	[refresh_timeout]=1
	[file_prompt]="Path: "
	[cmd_prompt]="M-x "
	[button_margin]=2
	[button_padding]=4
	[cancelhex]='18 0'
	[default_mode]="edit"
	[help_message]="(F10 to open menu)"
	[filepick_message]="Pick a file"
)
## Key bindings configuration
#      A keybindings for a mode x have to be in associative array named keys_${x}, else spis won't see them
#      keys_def is special case containing the common definitions.
#      It isn't used by itself anywhere, it exists purely for simplification.
#
#      A options for the keybings of given mode are defined by ass. array named key_options_${x}
#          [else] option defines what should happen if the input wasn't any of keys defined in keybings
keys_def=(
	[previous_line]='1b 5b 41 0'
	[next_line]='1b 5b 42 0'
	[forward_char]='1b 5b 43 0'
	[backward_char]='1b 5b 44 0'
	[scroll_down]='1b 5b 35 7e 0'
	[scroll_up]='1b 5b 36 7e 0'
	[select]='0'
)
keys_edit=(
	[${keys_def[previous_line]}]='previous-line'
	[${keys_def[next_line]}]='next-line'
	[${keys_def[forward_char]}]='forward-char'
	[${keys_def[backward_char]}]='backward-char'
	[${keys_def[scroll_down]}]='scroll-down'
	[${keys_def[scroll_up]}]='scroll-up'
	#[1b 5b 31 3b 32 41 0]='select_up'
	#[1b 5b 31 3b 32 42 0]='select_down'
	#[1b 5b 31 3b 32 43 0]='select_right'
	#[1b 5b 31 3b 32 44 0]='select_left'
	# TODO: selection
	[1b 0]='commandmode'
	[18 0]='quit'
	[1b 5b 32 31 7e 0]='menulinemenu'
	[10 0]='previous-line'
	[e 0]='next-line'
	[6 0]='forward-char'
	[1b 66 0]='forward-word'
	[2 0]='backward-char'
	[1b 62 0]='backward-word'
	[10 0]='scroll-down'
	[16 0]='scroll-up'
	[0]='new_line'
	[c 0]='new_line'
	[f 0]='write_buffer'
	[12 0]='read_buffer'
	[1b 72 0]='set_buffer_file'
	[14 0]='execute'
	[4 0]='delete_line'
	[13 0]='shell'
	[7f 0]='backspace'
	[1b 71 0]='die'
	[1b 67 0]='menukey'
	[1b 78 0]='cmd'
	[1 0]='move-beginning-of-line'
	[1b 5b 48 0]='move-beginning-of-line'
	[5 0]='move-end-of-line'
	[1b 5b 46 0]='move-end-of-line'
)
keys_interact=(
	[${keys_def[previous_line]}]='previous-line'
	[${keys_def[next_line]}]='next-line'
	[${keys_def[forward_char]}]='forward-char'
	[${keys_def[backward_char]}]='backward-char'
	[${keys_def[scroll_down]}]='scroll-down'
	[${keys_def[scroll_up]}]='scroll-up'
	[${keys_def[select]}]='file_select'
	[68 0]='toggle_hidden'
)
keys_view=(
	[${keys_def[previous_line]}]='previous-line'
	[${keys_def[next_line]}]='next-line'
	[${keys_def[forward_char]}]='forward-char'
	[${keys_def[backward_char]}]='backward-char'
	[${keys_def[scroll_down]}]='scroll-down'
	[${keys_def[scroll_up]}]='scroll-up'
	[${keys_def[select]}]='view_exit'
)
keys_command=(
	[${keys_def[previous_line]}]='previous-line'
	[${keys_def[next_line]}]='next-line'
	[${keys_def[forward_char]}]='forward-char'
	[${keys_def[backward_char]}]='backward-char'
	[${keys_def[scroll_down]}]='scroll-down'
	[${keys_def[scroll_up]}]='scroll-up'
	[69 0]='insertmode'
	[61 0]='ansertmode'
)
keys_menu=(
	[${keys_def[previous_line]}]='menuup'
	[${keys_def[forward_char]}]='menudown'
	[${keys_def[select]}]='menuselect'
)
key_options_menu=(
	[else]='menuleave'
)
## Style
#      Defined in escape codes.
style=(
	[TODO]='\e[0;97;45m'
	[NOTE]='\e[0;97;100m'
	[menuline]='\e[0;37;40m'
	[menuitem]='\e[0;37;40m'
	[selected]='\e[30;45m'
	[button]='\e[0;97;100m'
	[link]='\e[94m'
	[menuitemselected]='\e[30;45m'
	[infoline]='\e[40;97m'
	[number]='\e[0;90m'
	[numberempty]='\e[0;90m'
	[numberselected]='\e[0;91m'
	[tab]='\e[0;90m'
	#syntax
	[quotevar]='\e[0;36;48m'
	[comment]='\e[3;37;48m'
	[variable]='\e[0;96m'
	[option]='\e[0;93m'
	[flow]='\e[0;93;m'
	[bracket]='\e[1;95m'
	[quote]='\e[0;92m'
	[dquote]='\e[0;32m'
	[set]='\e[0;94;108m'
	[fn]='\e[0;30;44m'
	[keyword]='\e[0;91m'
)
## charmap
#TODO: this will be usesfull for later implementation of ligatures and stuff
charmap=(
	#[0] is reserved for any unmapped char
	[	]='t'
	[ ]='s'
	#[	-render]="${options[tabchar]}"
)
menulinemenu() {
	declare -ng menucon=menufancy
	#menulinepy=$(( sizy - ${#menufancy[@]} ))
	menu
}
menulineedit=(
	[File]=menufile	[Help]=menuhelp
	[Keys]=menukey	    [Redraw]=refresh
	[Debug]=menudebug
)
menufile() { declare -ng menucon=menufile; menu; }
menufile=(
	[Quit    C-x  ]="quit"
	[Open loc M-r ]="set_buffer_file"
	[Execute  C-t ]="execute"
	[Save     C-o ]="write_buffer"
	[File picker  ]="filepick"
)

menuhelp() { declare -ng menucon=menuhelp; menu; }
menuhelp=(
	[Keybinding          ]=menukey
	[About               ]=about
)

menukey() { declare -ng menucon=menukey; menu; }
menukey=(
	[Exit         C-x ]="quit"
	[New Line C-l | ‚èé ]="new_line"
	[Set target   M-r ]="set_buffer_file"
	[Read File    C-r ]="read_buffer"
	[Write Out    C-o ]="write_buffer"
	[Delete Line  C-d ]="delete_line"
	[Toggle Mouse C-e ]="mtoggle"
	[Prev Line    C-p ]="previous-line"
	[Next Line    C-n ]="next-line"
	[Prev Page    C-y ]="scroll-down"
	[Next Page    C-v ]="scroll-up"
	[Execute      C-t ]="execute"
	[Shell        C-s ]="shell"
	[Exit no save M-q ]="die"
)

menudebug() { declare -ng menucon=menudebug; menu; }
menudebug=(
	[clear      ]=clr
	[refresh    ]=refresh
	[backspace  ]=backspace
	[right      ]=forward-char
	[left       ]=backward-char
	[inputcodes ]=inputcodes
)

syntax=(
	[bash]=builtin_syntax_bash	[sh]=builtin_syntax_bash
	[ksh]=builtin_syntax_bash	[mksh]=builtin_syntax_bash
	[dash]=builtin_syntax_bash	[zsh]=builtin_syntax_bash
	[conf]=builtin_syntax_conf	[unknown]=builtin_syntax_unknown
)

commands=(
	[quit]='quit'
	[newline]='new_line'
	[set-buffer-file]='set_buffer_file'
	[read-file]='read_buffer'
	[write-file]='write_buffer'
	[delete-line]='delete_line'
	[toggle-mouse]='mtoggle'
	[execute]='execute'
	[shell]='shell'
	[force-quit]='die'
	[about]='about'
	[backspace]='backspace'
	[menu]='menu'
	[menul]='menulinemenu'
	[input]='inputcodes'
	[scroll-up]='scroll-up'
	[scroll-down]='scroll-down'
)

filepickmenu=(
	[toggle hidden \(h\)]="toggle_hidden"
)

## rest of this garbageware

version="Spis dev"
buffer=() # File contents
buffersyntax=() # File contents
line=1 # Currently selected line (0 means the buffer is empty)
base=1 # Top-most line shown
rl=0 # Position of the cursor in $line
menulinepy=0; menulinep=0 # menu positions
file= # Currently addressed file
info="${version}: insanity" # Feedback text in the status bar
modified=false # Tracking whether a file was modified
mode="${options[default_mode]}"
menuline=menulineedit # Set default menuline for file editing
help_message="${options[help_message]}"
offx=0 # TODO: abuse offsets and size of main render
offy=1
sizx=$COLUMNS
sizy=$((LINES - 1))
update=1
case "${options[menuline]}" in
	"true") toplines=1;;
	"false") toplines=0;;
esac
bottomlines=2
rst='\e[0;0m'
for item in "${!menulineedit[@]}"; do
	menufancy+=(["$(printf '%-12s' "$item")"]="${menulineedit["$item"]}")
done
menufancy+=([Quit        ]=quit)


clr() {
	printf "\033c" # clear
}

# getting the cursor position
getcy() {
	local pos
	IFS='[;' read -p $'\e[6n' -d R -a pos -rs || echo "failed with error: $? ; ${pos[*]}"
	echo "${pos[1]}"
}
getcx() {
	local pos
	IFS='[;' read -p $'\e[6n' -d R -a pos -rs || echo "failed with error: $? ; ${pos[*]}"
	echo "${pos[2]}"
}

commandmode() { mode="command"; statusline; }
insertmode() { mode="edit"; statusline; drawc; }
ansertmode() { mode="edit"; statusline; forward-char; }

refresh() {
	clr
	message="reloaded..."
	megaredraw
	redraw
	message=
}

cmd() {
	printf '\e[%s;0H' $((sizy + offy))
	printf '\e[?25h'
	if read -re -p "${options[cmd_prompt]}" command; then
		for lcmd in "${!commands[@]}"; {
			[ "$command" = "$lcmd" ] && "${commands[$lcmd]}"
		}
	fi
}

pipesyntax() {
	comment=false
	word=
	bckIFS="${IFS}"
	IFS=
	while read -rsn1 char
	do
		[ "$char" = " " ] && syntax && word='' && printf ' ' && continue
		[ "$char" = "	" ] && {
			syntax
			word=''
			printf "${style[tab]}%s\e[0;0m" "${options[tabchar]}"
			continue
		}
		[ -z "$char" ] && syntax && word='' comment='false' && echo && continue
		word="${word}${char}" && printf '%s\e[%sD' "$word" "${#word}"
	done
	IFS="${bckIFS}"
}


builtin_syntax_bash() {
	case "${word:0:2}" in
		'"$') printf "${style[quotevar]}%s${rst}" "${word}"; return ;;
	esac
	case "${word:0:1}" in
		'#') printf "${style[comment]}%s${rst}" "${word}" && comment=true; return;;
		'$') printf "${style[variable]}%s${rst}" "${word}"; return ;;
		'-') printf "${style[option]}%s${rst}" "${word}"; return ;;
	esac
	"${comment}" && printf "${style[comment]}%s${rst}" "${word}" && return
	case "${word}" in
		'||') printf "${style[flow]}%s${rst}" "${word}"; return ;;
		'&&') printf "${style[flow]}%s${rst}" "${word}"; return ;;
		']') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'[') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'[[') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		']]') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		')') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'(') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'{') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		'}') printf "${style[bracket]}%s${rst}" "${word}"; return ;;
		';') printf "${style[flow]}%s${rst}" "${word}"; return ;;
		'function') printf "${style[fn]}%s${rst}" "${word}"; return ;;
		*"'"*) printf "${style[quote]}%s${rst}" "${word}" && return ;;
		*'"'*) printf "${style[dquote]}%s${rst}" "${word}"&& return ;;
		*'='*) printf "${style[set]}%s${rst}" "${word}"; return ;;
	esac
		   
	[[ "${word: -2}" = '()' ]] && printf "${style[fn]}%s${rst}" "${word}" && return
	case "${word}" in
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|'declare'|'typeset'|'local'|'let'|'shopt'|'trap'|'set'|'eval') printf "${style[keyword]}%s${rst}" "${word}" && return
	esac
	printf "${rst}%s" "${word}"
}
builtin_syntax_unknown() {
	printf "${rst}%s" "${word}"
}
builtin_syntax_conf() {
	[[ "${word}" =~ "#" ]] && printf "${style[comment]}%s${rst}" "${word}" && comment=true && return
	"${comment}" && printf "${style[comment]}%s${rst}" "${word}" && return
	printf "${rst}%s" "${word}"
}

syntax() {
	for s in "${!syntax[@]}"; do
		[ "$s" = "$filetype" ] && {
			[ "${options[todonote]}" = true ] && {
				case "$word" in
					'NOTE:') printf "${style[NOTE]}%s${rst}" "${word}"; return ;;
					'TODO:') printf "${style[TODO]}%s${rst}" "${word}"; return ;;
				esac
			}
			"${syntax[$s]}"
		} && return
	done
	"${syntax[unknown]}"
}

inputcodes() {
	debuginput
	while true; do
		local -a k=()
		local -i i=1
		[ "${options[mouse]}" = true ] && echo -ne "\e[?1000;1006;1015h"
		if read -rsN1 -t${options[refresh_timeout]} k[0]; then # Check for ready input
			while read -rsN1 -t0.0001 k[$i]; do ((i++)); done # Multibyte hack
			debuginput "$(printf '%s' "${k[@]}")" # Handle keypress event
			[ $? = 69 ] && break
		fi
	done
	redraw
}
debuginput() {
	hexkey=()	
	i=0
	echo "$1" | while read -rsn1; do
		hexkey[i]="$(printf "%x\n" "'${1:$i}")"
		((i++))
	done
	if [ "${hexkey[*]}" = "${options[cancelhex]}" ]; then
	   return 69
	fi
	clr
	topline "Input codes (exit keybind is ${options[cancelhex]})"
	printf "${style[windowcontent]}"
	printf "\033[2;0H"
	for ((i=2;i<=sizy;i+=1)); do
		printf '\033[%s;0H' $i
		printf '%*s' "$sizx"
	done
	printf "\033[2;0H"
	echo "${hexkey[@]}"
}

basenam() {
	for file in "$@"; do
	    file="${file%/}"
	    printf '%s\n' "${file##*/}"
	done
}
filetype() {
	local filename shebang extension
	local -a filenamesplit shebangsplit
	[ $# = 0 ] && return
	IFS='.'
	filename="${1%/}"
	filename="${filename##*/}"
	[ "$filename" = 'COMMIT_EDITMSG' ] && echo conf && return
	filenamesplit=($filename)
	extension="${filenamesplit[-1]}"
	[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	case "${shebang:0:1}" in
		'#')
		shebang="${shebang%/}"
		IFS=' '
		shebangsplit=("${shebang##*/}")
		printf '%s\n' "${shebangsplit[-1]}";;
		'!')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		*) echo unknown
	esac
}
filellenght() {
	fll="${#buffer[@]}"
	fll="${#fll}"
}
set_buffer_file() {
	printf '\e[%s;0H' "${sizy}"
	printf '\e[D\033[1;93;108m' #make prompt nicer
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h' # Enable cursor
    if read -rei "$1$file" -p "${file_prompt}" file; then
        modified=true
    fi
    bind 'set disable-completion on' 2>/dev/null
}
read_buffer() {
	clr_buffer
	#set_buffer_file "$1" # Update target file (pass on default if present)
	filetype="$(filetype "$1")"
	file="$1"
	mapfile -t -O 1 buffer <"$file" # Read file into an array
	pipesyntax < "$file" | mapfile -t -O 1 buffersyntax # TODO: make fast
	charexpand < "$file" | mapfile -t -O 1 bufferexpand # TODO: make fast
	filellenght
	if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
		line=1 # Indicate that we have a buffer loaded
		modified=false
		info="${file}: ${#buffer[@]}"
	else
		info="{$file}: empty"
	fi
}
clr_buffer() {
	buffer=()
	buffersyntax=()
	bufferexpand=()
}

topline() {
	local -i ln=${#1}
	printf "${style[windowline]}%s\e[?25l%*s" "$1" "$(( $sizx - ln ))"
}
toggle_hidden() {
	((hidden==0)) && hidden=1 || hidden=0
	filepick
}
filepick() {
	help_message="${options[filepick_message]}"
	declare -gn menuline=filepickmenu
	line=0
	rl=0
	base=1
	clr_buffer
	filetype="i*" # Internal file type
	file="filepicker*" # All internal "files" should end with star
	mapfile -t -O 1 buffer <<< "$(pickls)"
	for idx in "${!buffer[@]}"; do
		if [ -d "${buffer[idx]}" ]; then
			buffersyntax[idx]="$(printf ${style[link]})""${buffer[idx]}"
		else
			buffersyntax[idx]="${buffer[idx]}"
		fi
		bufferexpand[idx]="${buffer[idx]}"
	done
	mode=interact # general internal interactive mode
	filellenght # drowning in sea of murky logic
	if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
		line=1 # Indicate that we have a buffer loaded
		modified=false
		info="$PWD"
	else
		info="error: empty"
	fi
	redraw
}
file_select() {
	local line="${buffer[line]}"
	if [ -d "$line" ]; then
		cd "$line"
		filepick
	else
		read_buffer "$line" || exit 1
		help_message="${options[help_message]}"
		declare -gn menuline=menulineedit
		mode=edit
		redraw
	fi
}
pickls() {
	((hidden==1)) || printf '..\n'
	((hidden==1)) && printf '%s\n' .*
	printf '%s\n' *
}
cparray() {
	local -n source="$1"
	local -n target="$2"
	for idx in "${!source[@]}"; do
		target[idx]="${source[idx]}"
	done
}

save() {
	local name="$1"
	
	local -n savedhelp_message="help_message${name}"
	local -n savedfiletype="filetype${name}"
	local -n savedfile="file${name}"
	local -n savedmode="mode${name}"
	
	local -n savedmenuline="menuline${name}"
	
	cparray buffer "buffer${name}"
	cparray buffersyntax "buffersyntax${name}"
	cparray bufferexpand "expand${name}"
	
	savedhelp_message="$help_message"
	savedfiletype="$filetype"
	savedfile="$filetype"
	savedmode="$mode"
	savedmenuline="${!menuline}"
}
restore() {
	clr_buffer
	local name="$1"
	
	local -n savedhelp_message="help_message${name}"
	local -n savedfiletype="filetype${name}"
	local -n savedfile="file${name}"
	local -n savedmode="mode${name}"

	local -n savedmenuline="menuline${name}"
	
	cparray "buffer${name}" buffer
	cparray "buffersyntax${name}" buffersyntax
	cparray "expand${name}" bufferexpand
	
	help_message="$savedhelp_message"
	filetype="$savedfiletype"
	file="$savedfile"
	mode="$savedmode"
	
	declare -ng menuline="${savedmenuline}"
}

about() {
	save openfile
	update=0
	#sizx=$((COLUMNS / 2))
	#sizy=$((LINES / 3))
	#offx=$((COLUMNS / 2 - COLUMNS / 4))
	#offy=$((LINES / 2 - LINES / 6))
	mode=view
	filetype="i*"
	file="about*"
	help_message="About"
	declare -gn menuline=menulineabout
	menulineabout=(
		[quit]='view_exit'
	)
	buffer=(
		'This is Spis, one component of the Bash/Bash operating system.'
		''
		"${version}, text \"editor\" written bash. git repo: https://github.com/nyeta/spis"
		'originally based on https://github.com/comfies/bed'
		''
		   )
	megaredraw
	clr
	redraw
}
view_exit() {
	restore openfile
	redraw
}


write_buffer() {
    true >"$file" # Set the file to an empty text file
    for ln in "${buffer[@]}"; do # Write in the buffer to the file
        echo "$ln" >>"$file"
    done
    modified=false
    message="Wrote ${#buffer[@]} lines to '$file'"
}

megaredraw(){
	printf '%s\n' "${buffer[@]}" | pipesyntax | mapfile -t -O 1 buffersyntax
	printf '%s\n' "${buffer[@]}" | charexpand | mapfile -t -O 1 bufferexpand
}
megaredrawline(){
	buffersyntax[line]="$(printf '%s' "${buffer[line]}" | pipesyntax)"
	bufferexpand[line]="$(printf '%s' "${buffer[line]}" | charexpand)"
}

charexpand() {
	bckIFS="${IFS}"
	IFS=
	while read -rsn1 char
	do
		[ -z "$char" ] && echo && continue
		case "${char}" in
			'	')
				local -i i
				for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
					printf '%s' "${charmap[	]}"
				done;;
			' ') printf '%s' "${charmap[ ]}";;
			*)
				printf '0';;
		esac
	done
	IFS="${bckIFS}"
}


new_line() {
    buffer=("" "${buffer[@]:1:line}" "" "${buffer[@]:line+1}")
    unset 'buffer[0]'
    modified=true
	buffer[line+1]=${buffer[line]:rl:${#buffer[line]}}
	buffer[line]=${buffer[line]:0:rl}
	rl=0
	filellenght
	megaredraw
	next-line
	redraw
}

delete_line() {
    buffer=("" "${buffer[@]:1:line-1}" "${buffer[@]:line+1}")
    unset 'buffer[0]'
    ((line > ${#buffer[@]})) && previous-line
    modified=true
	filellenght
    megaredraw
	redraw
}

backspace() {
	if [ "${#buffer[line]}" = 0 ]; then
		delete_line
		rl="${#buffer[line]}"
		redraw
		return 0
	fi
	local -i rlr
	unset ta
	local ta
	ta=${bufferexpand[line]:0:rl}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((rl + ta / 4 - ta))
	if [ $rlr = 0 ]; then
		buffer[line-1]="${buffer[line-1]}${buffer[line]}"
		delete_line
		rl=${#bufferexpand[line]}
		redraw
		return 0
	fi
	buffer[line]="${buffer[line]:0:$(( rlr - 1 ))}${buffer[line]:${rlr}}"
	backward-char #go back with cursor
	megaredrawline # copy the buffer into buffersyntax and bufferexpand
	redraw #draw it
	modified=true
}

quit() {
	if [[ "$modified" == "true" ]]; then
		while true; do
			printf '\e[%s;0H%s' $((sizy + offy)) "Save file ${file}? (y, n, c): "
			printf '\e[?25h'
			if read -rn 1  answer; then
				case "$answer" in
					'y') write_buffer; die;;
					'n') die;;
					'c') return;;
					'*') continue;;
				esac
			fi
		done
	else
		die
	fi

}

previous-line() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line > 1)) && ((line--)) # As long as we can keep going up, go up
        ((line < base + 1)) && ((base--)) && # Push back the top if we need to
        ((base <= 0)) && base=1 # Don't push back if our base is at 1
        [ -z "$bckrl" ] && bckrl="${rl}"
        (( "${#buffer[line]}" < "${rl}" )) && rl="${#buffer[line]}"
        (( "${#buffer[line]}" > "${rl}" )) && rl=bckrl
    done
	redraw
}

scroll-down() {
    previous-line $((sizy - 3))
}

next-line() {
    for ((i = 0; i < ${1:-1}; i++)); do
        ((line < ${#buffer[@]})) && ((line++)) # If we can go down, go down
        ((line > base + sizy - 3 - bottomlines)) && ((base++)) && # Move window down if needed
        [ -z "$bckrl" ] && bckrl="${rl}"
        (( "${#buffer[line]}" < "${rl}" )) && rl="${#buffer[line]}"
        (( "${#buffer[line]}" > "${rl}" )) && rl=bckrl
    done
	redraw
}

scroll-up() {
    next-line $((sizy - 3))
}

execute() {
    ((line == 0)) && return # If the line is not possible, do nothing
    printf '\e[?25h\e[%sH' "$((line + 2 - base))" # Reset cursor position and enable cursor
    read -re -p "$(printf '%4s ' "$")" # Present editable line
    if [[ "$REPLY" != "${buffer[line]}" ]]; then # If the line is changed, update and inform
        buffer[line]="$($REPLY)"
        modified=true
    fi
    megaredraw
    redraw
}
forward-char() {
	case "${bufferexpand[line]:rl+1:1}" in
		't') rl=$(( rl + ${#options[tabchar]}));;
		*) ((rl++));;
	esac
	[ "$rl" -gt "${#bufferexpand[line]}" ] && { rl=0; next-line; }
	bckrl=
	#redraw
	statusline
	drawc
}
backward-char() {
	case "${bufferexpand[line]:rl-1:1}" in
		't') rl=$(( rl - ${#options[tabchar]}));;
		*) ((rl--));;
	esac
	[ "$rl" -lt 0 ] && { previous-line; rl="${#bufferexpand[line]}"; }
	bckrl=
	statusline
	drawc
}
move-beginning-of-line() {
	rl=0
	statusline
	drawc
}
move-end-of-line() {
	rl="${#bufferexpand[line]}"
	statusline
	drawc
}
forward-word() {
	((rl == ${#bufferexpand[line]})) && {
		next-line
		move-beginning-of-line
	}
	while true; do
		((rl < ${#bufferexpand[line]})) && ((rl++)) || break
		case "${bufferexpand[line]:rl:1}" in
			't'|'s') break;;
		esac
	done
	redraw
}
backward-word() {
	((rl == 0)) && {
		previous-line
		move-end-of-line
	}
	while true; do
		((rl > 0)) && ((rl--)) || break
		case "${bufferexpand[line]:rl:1}" in
			't'|'s') break;;
		esac
	done
	redraw
}
shell() {
	clr
	bash # NOTE: in theory an external command
	redraw
}

die() {
    bind 'set disable-completion off' 2>/dev/null # Enable completion
    printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
    echo -e "\e[?1000;1006;1015l" #disable mouse tracking
	clr # TODO fix the buffer switching
    exit "${errno:-0}" # Assume that we are exiting without an error
}
mtoggle() {
	[ "${options[mouse]}" = true ] && echo -ne "\e[?1000;1006;1015l" && options[mouse]=false && return
	[ "${options[mouse]}" = false ] && echo -ne "\e[?1000;1006;1015h" && options[mouse]=true && return
}
menuclick() {
	#determine which item should be triggered
	[ -z "$1" ] && menulinep=0 || menulinep=$1
	local cx="$offx"
	for a in "${!menuline[@]}"; {
		la="${#a}"
		((menulinep>cx)) && ((menulinep<(cx + la + 1))) && ${menuline[$a]}
		cx=$(( cx + la + 1 ))
	}
}
menudraw() {
	printf '\e[?25l'
	printf '\e[%s;0H' $menulinepy
	local mi=0
	for action in "${!menucon[@]}"; do
		if ((mi == menuselection)); then
			printf "\e[%sC${style[menuitemselected]}%s${rst}\n" $menulinep "$action"  
		else
			printf "\e[%sC${style[menuitem]}%s${rst}\n" $menulinep "$action"
		fi
		((mi++))
	done
}
menuup() {
	((menuselection > 0)) && ((menuselection--))
	menudraw
}
menudown() {
	((menuselection < ${#menucon[@]} -1)) && ((menuselection++))
	menudraw
}
menuselect() {
	local mi=0
	for action in "${!menucon[@]}"; do
		((mi == menuselection)) && "${menucon[$action]}"
		((mi++))
	done
}
menuleave() {
	ismenu=0
	mode="${modebackup}"
	overlay=()
	redraw
}
menu() {
	((ismenu == 0 )) && modebackup="${mode}"
	ismenu=1
	declare -ig menuselection=0
	mode='menu'
	overlay+=('menudraw')
	redraw
}

redraw() {
	((update==1)) && {
		sizx=$COLUMNS
		sizy=$((LINES - 1))
	}
	[ "${options[menuline]}" = true ] && {
		printf "\e[0m\e[%s;%sH${style[menuline]}\e[?25l%*s\r%s" "$offy" "$offx" "$sizx" "$help_message"
		printf '\e[%sG%s\e[0m\n' "$offx" "${!menuline[*]}"
	} || printf "\e[%s;%sH" "$offy" "$offx"
	# Iterate over shown lines
	for ((i = base; i - base < sizy - (bottomlines + toplines ) + 1; i++)); do
		printf "${style[numberselected]}"
		((i != line)) && printf "${style[number]}" # Fade line number if not selected
		((i > ${#buffer[@]})) && printf "\e[%sG${style[numberempty]}\e[K%$((fll/2))s~\e[m\n" "$offx"\
				|| printf "\e[%sG\e[K%${fll}s\e[m %s\n" "$offx" "$i" "${buffersyntax[i]}"
	done
	statusline
	commandline
	drawc
	# Render all overlays
	for o in "${overlay[@]}"; {
		"${o}"
	}
}
drawc() {
	printf '\e[?25h\e[%s;%sH' $((line + 1 - base + offy)) $((rl + fll + 2 + offx)) # move cursor to the line
}
statusline() {
	printf "\e[?25l\e[%s;%sH\n\e[%sG${style[infoline]}%*s\e[%sG%s %s (%s,%s)\e[m" \
	       $((sizy-2 + offy)) $((sizx + offx)) "$offx" $((sizx)) "$info" "$offx" \
	       "$mode" "$(basenam "$file")[$filetype]" "$line" "${rl}"
	#printf "\e[?25l\e[%s;%sH\n
}
commandline() {
	printf "\e[%s;%sH\n\e[?25l${style[commandline]}%s\e[m" \
	       $((sizy-2+offy)) $((sizx + offx)) "$message"
}

makehexkey() {
	hexkey=()
	local -i i=0
	echo "$1" | {
		while read -rsn1; do
			hexkey[i]="$(printf "%x\n" "'${1:$i}")"
			((i++))
		done
	}
}
keytype() {
	local -i x y known
	makehexkey "$1"

	local -n modekeys="keys_${mode}"
	for str in "${!modekeys[@]}"; do
		[ "$str" = "${hexkey[*]}" ] && {
			"${modekeys[$str]}"
			known=1
		}
	done
	((known == 0)) && {
		local -n key_options="key_options_${mode}"
		((${#key_options[@]})) && {
			[ -n "${key_options[else]}" ] && "${key_options[else]}"
		}
	}
	((known == 1)) && {
		return
	}
	[ "$mode" = 'edit' ] || return
	
	[ "${options[mouse]}" = true ] && {
		#parse mouse stuff somewhatish weirdly
		[ "${hexkey[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
		[ "${hexkey[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
		[ "${hexkey[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
		[ "${hexkey[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
		((skipnext==1)) && skipnext=0 && return
		((skipnext==0)) && [ "${hexkey[*]:0:2}" = '1b 5b' ] && {
			mapfile -t -d '' inputarray <<< "${1}"
			inputarray[-1]="${inputarray[-1]%?}"
			[ -z "${inputarray[2]}" ] && skipnext=1
			mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
			inputarray[-1]="${inputarray[-1]%?}"	
			mousemode="${inputarray[0]}"
			x="${inputarray[1]}"
			y="${inputarray[2]::-1}"
			#limitations of movenment
			[ $y = "$offy" ] && menuclick $x && return #handle menuline
			((x < (fll + offx + 2))) && {
				if [ "$mousemode" = '[<0' ]; then
					line=$(( base + ( (y - offy) - toplines) ))
					redraw
				elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
					clr
					echo enter line number
					read -re line
					redraw
				fi
				return
			}
			line=$(( base + ( y - offy - 1) ))
			rl=$(( x - (offx + fll + 2) ))
			((line > ${#bufferexpand[@]})) && line=${#bufferexpand[@]}
			((rl > ${#bufferexpand[line]})) && rl=${#bufferexpand[line]}
			redraw
			return
		}
	}
	#[ "${hexkey[*]:0:3}" = '1b 5b 3c' ] && return
	[ "${hexkey[*]:0:1}" = '1b' ] && return # TODO: prevent escape codes without hacky blocking
	[ "$mode" = edit ] && {
		local -i rlr
		unset ta
		local ta
		ta=${bufferexpand[line]:0:rl}
		ta=${ta//[^t]}
		ta=${#ta}
		rlr=$((rl + ta / 4 - ta))	
		buffer[line]="${buffer[line]:0:${rlr}}$1${buffer[line]:${rlr}}" #add at cursor position - amount of tabs * tab size
		#go right with cursor
		megaredrawline #not sure why this is needed but it prevents duplication of the letter
		forward-char
		redraw
		[ "$1" = '	' ] && printf '\e[%sC' $((${#options[tabchar]} - 1))
		modified=true
	}
}
main() {
	[ "${options[mouse]}" = true ] && print '%s' "\e[?1000;1006;1015h" #enable mouse tracking
    if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
        if [ -d "$1" ]; then
			cd "$1" || exit
			filepick # enter the file selector in specified folder
		else
			read_buffer "$1"
		fi
    else
		filepick # enter the file selector
	fi
	begin
}
begin() {
    redraw
    while true; do
        local -a k=()
        local -i i=1    
        if read -rsN1 -t"${options[refresh_timeout]}" k[0]; then # Check for ready input
			while read -rsN1 -t0.0001 k[$i]; do ((i++)); done # Multibyte hack
			keytype "$(printf '%s' "${k[@]}")" # Handle keypress event
		fi
	done
}

redrawa() {
	redraw #i have no idea why it has to be twice to work
	redraw
}

main "$@"
printf '\e[?7h'
