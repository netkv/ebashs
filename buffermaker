#!/bin/bash
version="0.9-WIP-1"
log_buffer+=('' 'START')
## Buffermaker
# Pure bash tui framework (wip)

shopt -s lastpipe # For syntax highlighting
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize && (:) # Enable and then trigger a terminal size refresh

declare -r DEFIFS="$IFS"
declare -A highlight faces faces_raw options charmap alias descriptions
declare -A menulineedit diredmenu menulinedebug
declare -A menufancy
declare -A keys_def keys_global
declare -a k_hex buffers_l log_buffer extensions modes=('keys_global')
declare -n buffer bf_s bf_e bf_d
declare -i menuloc_x menuloc_y toplines bottomlines hidden ismenu comment current_count _isdone
declare -n menucon
declare message reset readin

function load-default-config {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options â†’ define-options() â†’ ass. array options
	#				global-set â†’ global-set-key â†’ define-key global â†’ as. ar. keys_global
	#				add-mode â†’ local-set-key â†’ define-key <keys> â†’ a. a. keys_<keys>
	#					mode-options â†’ local-set-mode-option â†’ define-mode-option â†’ a. a. key_options_<keys>
	#				set-alias â†’ add-alias â†’ a. a. alias
	#				add-menu â†’ local-set-menu â†’ define-menu <menu> â†’ menu_<menu>_0 & menu_<menu>_1
	#				set-highlight â†’ add-highlight â†’ a. a. highlight
					  
	set-options
		:: mouse 0
		:: todonote 0
		:: menu-line 0
		:: mode-line 0
		:: command-line 0 # note that disabling this means that any message will instead be draw on top of buffer
		:: line-number-mode 0
		:: empty-line-char ''
		:: tabchar '    '
		:: keep-message 0
		:: log 0
		:: log-functions 0
		:: tty-linuxfb 1 # enable truecolor support for framebuffer
		:: full-redraw 0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		:: esc-to-meta 0
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value
	
	add-mode format
		:: '[left]' format-left
		:: '[up]' format-up
		:: '[right]' format-right
		:: '[down]' format-down
		:: 'RET' link-enter
		:: "$(kbd C-c)" quit-view
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd M-v)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top_menu'
		:: "$(kbd C-g)" 'quit-prefix'
		mode-options
			:: else :
			:: disable-global 1

	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
default_faces=(
		reset '\e[m'
		default "$(:weight normal)"
		TODO "$(:background magenta)"
		NOTE "$(:background gray)"
		menu "$(:background yellow :foreground black)"
		menu-enabled-face "$(:background yellow :foreground black)"
		menu-back '\e[4m\e[1m'
		menu-selected-face "$(:background light-yellow :foreground black :weight bold)"
		#link "$(:foreground light-cyan)"
		link '\e[4;96m'
		title "$(:weight bold)"
		highlight "$(:weight bold :foreground light-red)"
		name "$(:foreground magenta)"
		#mode-line '\e[m'
		mode-line "$(:background yellow :foreground black)"
		hint "$(:foreground light-yellow)"
		file-name "$(:weight bold)"
		line-number "$(:foreground gray)"
		line-number-empty "$(:weight dim :foreground gray)"
		line-number-current-line "$(:weight bold :foreground light-red)"
		tab-face "$(:weight dim :foreground gray)"
		region "$(:weight bold :background gray)"
		minibuffer-prompt "$(:weight normal)"
		#button-text "$(:background gray :foreground white)"
		#button-highlight "$(:background gray :foreground light-yellow)"
		#button-shadow "$(:background gray :foreground yellow)"
		# ansi colors
		ansi-color-black '\e[40m'
		ansi-color-blue '\e[44m'
		ansi-color-bold '\e[1m'
		ansi-color-bright-black '\e[100m'
		ansi-color-bright-blue '\e[104m'
		ansi-color-bright-cyan '\e[106m'
		ansi-color-bright-green '\e[102m'
		ansi-color-bright-magenta '\e[105m'
		ansi-color-bright-red '\e[101m'
		ansi-color-bright-white '\e[107m'
		ansi-color-bright-yellow '\e[103m'
		ansi-color-cyan '\e[46m'
		ansi-color-green '\e[42m'
		ansi-color-inverse '\e[7m'
		ansi-color-italic '\e[3m'
		ansi-color-magenta '\e[45m'
		ansi-color-red '\e[41m'
		ansi-color-underline '\e[4m'
		ansi-color-white '\e[47m'
		ansi-color-yellow '\e[43m'
		# common colors for format stuff
		black      '\e[30m' gray          '\e[90m'
		red        '\e[31m' light-red     '\e[91m'
		green      '\e[32m' light-green   '\e[92m'
		yellow     '\e[33m' light-yellow  '\e[93m'
		blue       '\e[34m' light-blue    '\e[94m'
		magenta    '\e[35m' light-magenta '\e[95m'
		cyan       '\e[36m' light-cyan    '\e[96m'
		light-gray '\e[37m' white         '\e[97m'
)
	load-theme default_faces
}

## syntaxy sugar sugary syntax
log_buffer+=('- LOADING BASH EXTENSIONS -')
function @ifs { IFS="$DEFIFS"; }
	
# Make bash not be bashy enough
function @doc {
	mapfile -t "description_${desc_count}"
	descriptions["function_${1}_description"]="description_${desc_count}"
	((desc_count++))
}
@doc doc <<'EOF'
Adds description to a function
doc <function>
Description text is supplied from stdin, so mostly heredoc.
EOF
	
@doc load-default-config <<'EOF'
Load default config included with Ebashs.
EOF

# reverse of defun :D
function nufed {
	((_addfragment==1)) && {
		@add '='
		_addfragment=0
	}
	IFS=
	local -a fn
	local deffn="function $_function"$'\n'
	mapfile fn <<<"$(declare -f '=')"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
	_isdone=0
	@ifs
	unset '='
}
	
	
@doc copy-function <<'+'
copies function \$1 to function \$2
advantage of copying instead of creating wrapper alias functions should be in theory performance(?)

Little test script:
    1() {
    	echo hi > /dev/null
    }
    echo 1
    time for e in {0..100000}; do
    	1
    done
    
    2() {
    	1
    }
    echo 2
    time for e in {0..100000}; do
    	2
    done
    
    3() {
    	2
    }
    echo 3
    time for e in {0..100000}; do
    	3
    done
    
    4() {
    	3
    }
    echo 4
    time for e in {0..100000}; do
    	4
    done

output:
    1
    
    real	0m1,636s
    user	0m1,081s
    sys	0m0,540s
    2
    
    real	0m1,986s
    user	0m1,453s
    sys	0m0,518s
    3
    
    real	0m2,380s
    user	0m1,873s
    sys	0m0,491s
    4
    
    real	0m2,768s
    user	0m2,154s
    sys	0m0,595s

It seems like there's small performace gain.
+
function copy-function {
	local -a fn
	local deffn="function $2"$'\n'
	mapfile fn <<<"$(declare -f "$1")"
	for ((i=1; i<${#fn[@]}; i++)) {
		deffn+="${fn[i]}"
	}
	eval "$deffn"
}

function defun {
	if [ -z "$1" ]; then
		nufed
	else
		((desc_count++))
		log_buffer+=("    DEFUN: $1")
		((_isdone)) && nufed
		_addfragment="${_pass_addfragment}"
		descriptions["function_${1}_description"]="description_${desc_count}"
		_function="$1"
		_isdone=1
		_last_add=add-doc
	fi
} && @doc defun <<+
Begins defining an function
Function definition should be like:

defun something
:: some-docs
function = {
	...
}
defun something-else
:: ...	
function = ...
defun this-nonsense
...
def.. ...
nufed
+

function ::
case "$_last_add" in
	add-menu) local-set-menu "$@";;
	set-alias) add-alias "$@";;
	set-highlight) add-highlight "$@";;
	global-set) global-set-key "$@";;
	set-options) define-option "$@";;
	add-doc) add-doc "$@";;
	add-mode) local-set-key "$@";;
	mode-options) local-set-mode-option "$@";;
	set-buffer) local-set-buffer-data "$@"
esac

function add-doc {
	local -n cdoc="description_${desc_count}"
	cdoc+=("${_indent}$*")
}
function doc {
	((desc_count++))
	descriptions["function_${1}_description"]="description_${desc_count}"
	_function="$1"
	_last_add=add-doc
	_indent=''
	shift
	[ -n "$*" ] &&
		:: "$*"
}
copy-function doc @@

@@ :+ Add documentation indent
function :+ {
	_indent+="    "
	:: "$*"
}
@@ :- Remove documentation indent
function :- {
	_indent="${_indent:0:${#_indent}-4}"
	:: "$*"
}
# hell

@@ focus set magic :: function
function focus {
	_last_add="$1"
}

@@ declare-new-buffer Create new text buffer
function declare-new-buffer {
	_last_add='set-buffer'
	((current_count++))
	set-buffer "bf_${current_count}"
	buffers_l+=("$current_buffer")
	last_line=1
	declare -Ag "${current_buffer}_bf_d"
	bf_d=(
		# some sane default values
		[line]=0
		[base]=1
		[column]=0
		[modified]=0
	)
}

@@ local-set-buffer-data
:: set bf_d[] array of currently \"focused\" buffer
function local-set-buffer-data {
	while [ -n "$2" ]; do
		bf_d["$1"]="$2"
		shift 2
	done
}

@@ [auto] Checks bf_d[] array and set\'s needed missing values automatically
function [auto] {
	[ -z "${bf_d[loc-x]}" ] && bf_d[loc-x]=1
	[ -z "${bf_d[loc-y]}" ] && bf_d[loc-y]=1
	[ -z "${bf_d[size-x]}" ] && bf_d[size-x]=$COLUMNS
	[ -z "${bf_d[size-y]}" ] && bf_d[size-y]=$((LINES - 1))
	[ -z "${bf_d[syntax]}" ] && set-syntax 
}

@@ defun-fragment Same as defun but includes fragments for the function
function defun-fragment {
	_pass_addfragment=1
	defun "$@"
}

# fragments act basically like macros but with cooler name
# see redraw-buffer function for example usage
@@ fragment Creates a function-insertable macro
function fragment {
	log_buffer+=("        FRAGMENT: $1")
	declare -ag "_fragment_$1"
	mapfile "_fragment_$1"
}
	
@@ @add Adds fragment to a function
function @add {
	local -a _add_fn
	local -a _add_nfn
	local -i _add_f
	local -i _add_hf
	local _add_nfnline
	mapfile _add_fn < <(declare -f -- "$1")
	IFS=' '
	for _add_l in "${!_add_fn[@]}"; {
		_add_f=0
		_add_hf=0
		_add_nfnline=
		for _add_w in ${_add_fn[_add_l]}; {
			if [ "$_add_w" = '@' ]; then
				_add_f=1
			elif ((_add_f)); then
				_add_f=0
				_add_hf=1
				local -n _add_fragment="_fragment_${_add_w//[^[:alnum:]]/}"
				for _add_l1 in "${!_add_fragment[@]}"; {
					_add_nfnline+=" ${_add_fragment[_add_l1]}"
				}
			else
				_add_nfnline+=" $_add_w"
			fi
		}
		((_add_hf)) || _add_nfn+="${_add_fn[_add_l]}"
		((_add_hf)) && _add_nfn+="$_add_nfnline"
	}
	eval "${_add_nfn[*]}"
}

# templates allow creating functions with code changes with minimal code
# @def creates function from teplate
# @def <template_name> <@var 1> <@var 2>...
# @: creates function from last defined template
# @: <@var 1> <@var 2>...
	
@@ template Creates a function template
:: Function template is turned into function with @def function
function template {
	log_buffer+=("        TEMPLATE: $1")
	_last_template="$1"
	declare -g "_template_$1"
	local -n tpl="_template_$1"
	IFS=''
	while read -r -d $'\n' tpll; do
		tpl+="$tpll"
	done
	@ifs
}

@@ @def Defines a function template
function @def {
	local -n _tpl="_template_$1"
	local _fn
	local -i _n=0
	shift
	for _w in $_tpl; {
		case "$_w" in
			'@var')
				_n=1;;
			*)
				((_n)) && {
					_n=0
					_fn+="${!_w} "
					continue
				}
				_fn+="$_w "
		esac
	}
	eval "$_fn"
}
	
@@ @: Calls @def with lastest defined template as argument
function @: { @def "$_last_template" "$@"; }

# unbashing bash one step at time Â°oÂ°

@@ _ Variable refernce helper
function _ {
	# this function is here to simplify stuff as writing overlong variables indexed by overloong variable index...
	# ...is quite tiring <3
	[ -z "$1" ] && {
		for n in "${refalias[@]}"; do
			unset "$n"
		done
		unset refalias
		return
	}
	declare -gn "$1"="$2"
	refalias+=("$1")
}

@@ __ Swap variable references
function __ {
	# swap two references
	local -n _swap_1="$1"
	local _swap_copy_1="${!_swap_1}"
	local -n _swap_2="$2"
	local _swap_copy_2="${!_swap_2}"
	declare -gn "$1"="${_swap_copy_2}"
	declare -gn "$2"="${_swap_copy_1}"
}

@@ @fn Shorthand for one line functions
function @fn {
	[ -z "$*" ] && exit 1 # error if empty
	local name="$1"
	shift
	eval "function $name { $@; }"
}

@@ copy-array
:: A univeral function to copy both normal and associative arrays
function copy-array {
	local -n source="$1"
	local -n target="$2"
	target=()
	for idx in "${!source[@]}"; {
		target[idx]="${source[idx]}"
	}
}

@@ append-array
:: Append array \$1 to \$2  
function append-array {
	local -n source="$1"
	local -n target="$2"
	for idx in "${!source[@]}"; {
		target+=("${source[idx]}")
	}
}

@@ setface Convert colors to escape codes
:: '$1' can be either one of colors:
:+     black
::     red
::     green
::     yellow
::     blue
::     magenta
::     cyan
::     ligth-gray
::     gray
::     light-red
::     light-green
::     light-yellow
::     light-blue
::     light-magenta
::     light-cyan
::     white
:- 'or hex. color (like "#bb2040")'
:: 'or indexed 256 color with "c" as prefix (like c127)'
:: 'for background color $mode has to be 48 and for foreground 38'
::
:: If \$TERM \(current "$TERM"\) is \'linux\' \& option tty-linuxfb is 1 try to use true color even for tty
:: Instead of normal '\e[$mode;r;g;bm' is used '\e]P$~1mode$Hexcode\e[$~2modem'
:+     '$mode 38 â†’ $~1mode 2 & $~2mode 32'
::     '$mode 48 â†’ $~1mode 1 & $~2mode 41'
:- Note that the linuxfb colors are very experimental and suffer from cursor implicitly overwriting them on movenment
function setface {
	[ -z "$1" ] && return
	case "$1" in
		black)      [ "$mode" = '38' ] && printf '\\e[30m' || printf '\\e[40m';;
		red)        [ "$mode" = '38' ] && printf '\\e[31m' || printf '\\e[41m';;
		green)      [ "$mode" = '38' ] && printf '\\e[32m' || printf '\\e[42m';;
		yellow)     [ "$mode" = '38' ] && printf '\\e[33m' || printf '\\e[43m';;
		blue)       [ "$mode" = '38' ] && printf '\\e[34m' || printf '\\e[44m';;
		magenta)    [ "$mode" = '38' ] && printf '\\e[35m' || printf '\\e[45m';;
		cyan)       [ "$mode" = '38' ] && printf '\\e[36m' || printf '\\e[46m';;
		light-gray) [ "$mode" = '38' ] && printf '\\e[37m' || printf '\\e[47m';;

		gray)          [ "$mode" = '38' ] && printf '\\e[90m' || printf '\\e[100m';;
		light-red)     [ "$mode" = '38' ] && printf '\\e[91m' || printf '\\e[101m';;
		light-green)   [ "$mode" = '38' ] && printf '\\e[92m' || printf '\\e[102m';;
		light-yellow)  [ "$mode" = '38' ] && printf '\\e[93m' || printf '\\e[103m';;
		light-blue)    [ "$mode" = '38' ] && printf '\\e[94m' || printf '\\e[104m';;
		light-magenta) [ "$mode" = '38' ] && printf '\\e[95m' || printf '\\e[105m';;
		light-cyan)    [ "$mode" = '38' ] && printf '\\e[96m' || printf '\\e[106m';;
		white)         [ "$mode" = '38' ] && printf '\\e[97m' || printf '\\e[107m';;
		*) case "${1::1}" in
			   '#')
				   if [ "$TERM" = 'linux' ] && ((options[tty-linuxfb])); then # Hack for linux framebuffer tty
					   case "$mode" in
						   38) printf '\\e]P2%s\\e[32m' "${1:1:6}" ;;
						   48) printf '\\e]P1%s\\e[41m' "${1:1:6}"
					   esac
				   else
					   local r="${1:1:2}"
					   local g="${1:3:2}"
					   local b="${1:5:2}"
					   printf '\\e[%d;2;%d;%d;%dm' "${mode}" $((16#$r)) $((16#$g)) $((16#$b))
				   fi;;
			   'c')
				   printf '\\e[%d;5;%dm' "${mode}" "${1:1}"
		   esac
	esac
	shift
	[ -n "$1" ] && "$@";
}

@@ :foreground
:: Set foreground color.
:: 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :foreground { mode=38; setface "$@"; }

@@ :background
:: Set background color.
:: 'See <a> doc-goto setface : <f> link setface </f> </a> for more info.'
function :background { mode=48; setface "$@"; }

@@ :mode Sets text mode:
:: '	inverse - inverses background and foreground'
function :mode {
	case "$1" in
		inverse) printf '\\e[7m';;
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
@@ :weight Sets thickness of text:
:+     bold
::     dim
::     normal
function :weight {
	case "$1" in
		bold) printf '\\e[1m';;
		dim) printf '\\e[2m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}

@@ :slant Sets slant of text:
:+     italic
::     normal
function :slant {
	case "$1" in
		italic) printf '\\e[3m';;
		normal) printf '\\e[m'
	esac
	shift
	[ -n "$1" ] && "$@";
}
	
@@ kbd Converts Emacs like key notation into hex.
function kbd {
	local -i i=0
	local out
	local in
	local -i ch=1
	# Surely there is better solution...
	case "$1" in
		C-a) printf '1 0' ;; C-b) printf '2 0' ;;
		C-c) printf '3 0' ;; C-d) printf '4 0' ;;
		C-e) printf '5 0' ;; C-f) printf '6 0' ;;
		C-g) printf '7 0' ;; C-h) printf '8 0' ;;
		C-i) printf '9 0' ;; C-j) printf 'a 0' ;;
		C-k) printf 'b 0' ;; C-l) printf 'c 0' ;;
		C-m) printf 'd 0' ;; C-n) printf 'e 0' ;;
		C-o) printf 'f 0' ;; C-p) printf '10 0';;
		C-q) printf '11 0';; C-r) printf '12 0';;
		C-s) printf '13 0';; C-t) printf '14 0';;
		C-u) printf '15 0';; C-v) printf '16 0';;
		C-w) printf '17 0';; C-x) printf '18 0';;
		C-y) printf '19 0';; C-z) printf '1a 0';;
		*)  ch=0
			case "${1:0:2}" in
				M-) in="${1:2:1}";;
				*) in="$1"
			esac
	esac
	((ch)) && return
	echo "$in" | {
		while read -rsn1; do
			out+="$(printf "%x\n" "'${in:$i}") "
			((i++))
		done
	}
	out=${out::-1}
	printf '%s' "${out}"
}

@@ define-key defines keybinding
:+     '$1' can be either:
::     '[function-key]'
::     '[arrow-key]'
::     '[prior | next]'
::     'RET'
::     'DEL'
::     '[delechar]'
::     'hex code ending with 0'
function define-key {
	local -n keys="keys_$1"
	case "$2" in
		#function keys
		'[f1]') keys[1b 4f 50 0]="$3";;
		'[f2]') keys[1b 4f 51 0]="$3";;
		'[f3]') keys[1b 4f 52 0]="$3";;
		'[f4]') keys[1b 4f 53 0]="$3";;
		'[f5]')  keys[1b 5b 31 35 7e 0]="$3";;
		'[f6]')  keys[1b 5b 31 37 7e 0]="$3";;
		'[f7]')  keys[1b 5b 31 38 7e 0]="$3";;
		'[f8]')  keys[1b 5b 32 39 7e 0]="$3";;
		'[f9]')  keys[1b 5b 32 30 7e 0]="$3";;
		'[f10]') keys[1b 5b 32 31 7e 0]="$3";;
		'[f11]') keys[1b 5b 32 33 7e 0]="$3";;
		'[f12]') keys[1b 5b 32 34 7e 0]="$3";;
		#arrow keys
		'[left]')  keys[1b 5b 44 0]="$3";;
		'[up]')    keys[1b 5b 41 0]="$3";;
		'[right]') keys[1b 5b 43 0]="$3";;
		'[down]')  keys[1b 5b 42 0]="$3";;
		#pg up & down
		'[prior]') keys[1b 5b 36 7e 0]="$3";;
		'[next]')  keys[1b 5b 35 7e 0]="$3";;
		#return
		'RET') keys[a 0]="$3";;
		#backspace & delete
		'DEL') keys[7f 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		'ESC') keys[1b 0 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		*) keys["$2"]="$3"
	esac
}

@@ local-set-key
:: Sets keybinding of lastly defined mode
:: See define-key for details
@fn local-set-key 'define-key "$_last_keys" "$@"'

@@ global-set-key
:: Sets keybinding of global mode
:: See define-key for details
@fn global-set-key 'define-key global "$@"'

@@ define-mode-option
:: Sets option of mode '$1'
function define-mode-option {
	local -n ko="key_options_$1"
	ko["$2"]="$3"
}

@@ local-set-mode-option See define-mode-option
@fn local-set-mode-option 'define-mode-option "$_last_keys" "$@"'

@@ mode-options Brings mode-options of lastly defined mode into \"focus\"
@fn mode-options '_last_add="mode-options"'


@@ add-alias Adds alias '$1' of command '$2...' to M-x
function add-alias {
	local name="$1"
	shift
	alias["$name"]="$@"
}

@@ set-alias Brings into \"focus\" alias setting
@fn set-alias '_last_add=set-alias'

@@ add-highlight Sets highlighting mode '$1' for file types '$2...'
function add-highlight {
	local name="$1"
	shift
	for i in "$@"; {
		highlight["$i"]="$name"
	}
}

@@ set-alias Brings into \"focus\" highlight setting
@fn set-highlight '_last_add=set-highlight'

@@ clear-screen clears screen
@fn clear-screen "printf '\033c'"

@@ add-mode
:: Adds keybing mode
function add-mode {
	log_buffer+=("        ADD MODE $1")
	_last_keys="$1"
	_last_add='add-mode'
	modes+=("keys_$1")
	declare -Ag "keys_$1"
	declare -Ag "key_options_$1"
}

@@ add-menu
:: Adds menu
function add-menu {
	# create new menu function & array
	log_buffer+=("        ADD MENU $1")
	eval "function menu-${1} { menu $1; }"
	declare -ag "menu_${1}_0"
	declare -ag "menu_${1}_1"
	_last_menu="$1"
	_last_add='add-menu'
}

@@ local-set-menu Sets \"focused\" menu item
@fn local-set-menu 'define-menu "$_last_menu" "$1" "$2"'

@@ global-set Brings into \"focus\" global mode
@fn global-set '_last_add=global-set'

@@ define-option Defines options[] buffer
@fn define-option 'options["$1"]="$2"'

@@ set-options Brings into \"focus\" options setting
@fn set-options '_last_add=set-options'

@@ define-menu
:: Defines item in menu '$1' with name '$2' with command '$3'
:: '    If command is "menu-top_menu" face menu-back is used.'
function define-menu {
	local -n menu_0="menu_${1}_0"
	local -n menu_1="menu_${1}_1"
	local item_0
	case "$3" in
		'menu-top_menu') item_0="$(printf '%b' "${faces[menu-back]}")$2";;
		*) item_0="$2"
	esac
	menu_0+=("$item_0")
	menu_1+=("$3")
}

@@ load-theme Loads theme from array
function load-theme {
	local -i t=0
	local k
	local -n theme="$1"
	for i in "${theme[@]}"; {
		((t==0)) && {
			k="$i"
			t=1
		} || {
			faces["$k"]="$i"
			faces_raw["$k"]="$(printf '%b' "$i")"
			t=0
		}
	}
	((t)) && errno=1 die
	# aliases for nicer formating
	faces+=(
		[bl]="${faces[black]}"
		[dr]="${faces[red]}"
		[dg]="${faces[green]}"
		[dy]="${faces[yellow]}"
		[db]="${faces[blue]}"
		[dm]="${faces[magenta]}"
		[dc]="${faces[cyan]}"
		[dw]="${faces[light-gray]}"
		[gr]="${faces[gray]}"
		[lr]="${faces[light-red]}"
		[lg]="${faces[light-green]}"
		[ly]="${faces[light-yellow]}"
		[lb]="${faces[light-blue]}"
		[lm]="${faces[light-magenta]}"
		[lc]="${faces[light-cyan]}"
		[lw]="${faces[light-white]}"
	)
	faces_raw+=(
		[bl]="${faces_raw[black]}"
		[dr]="${faces_raw[red]}"
		[dg]="${faces_raw[green]}"
		[dy]="${faces_raw[yellow]}"
		[db]="${faces_raw[blue]}"
		[dm]="${faces_raw[magenta]}"
		[dc]="${faces_raw[cyan]}"
		[dw]="${faces_raw[light-gray]}"
		[gr]="${faces_raw[gray]}"
		[lr]="${faces_raw[light-red]}"
		[lg]="${faces_raw[light-green]}"
		[ly]="${faces_raw[light-yellow]}"
		[lb]="${faces_raw[light-blue]}"
		[lm]="${faces_raw[light-magenta]}"
		[lc]="${faces_raw[light-cyan]}"
		[lw]="${faces_raw[light-white]}"
	)
}

@@ extension Set properites of extension
function extension {
	log_buffer+=("- LOADING EXTENSION $1 -")
	extensions+=("$1")
	declare -Ag "${1}_ext_d"
	declare -ng ext_d="${1}_ext_d"
}
@@ version: Set version of extension
function version: {
	ext_d[version]="$1"
}

log_buffer+=('- LOADING BASH EXTENSIONS DONE -')

## rest of this garbageware

@@ refresh Refreshes buffer
:: 'clears screen, reset syntax, redraws'
:: 'See <a> doc-goto clear-screen : <f> link clear-screen </f> </a> for more info.'
function refresh {
	clear-screen
	bf_s=''
	
	message="reloaded..."
	redraw
}

@@ switch-mode
:: Change current mode of buffer into '$1'
function switch-mode {
	bckmode="${bf_d[mode]}"
	bf_d[mode]="$1"
	redraw-statusline
}
@fn prefix switch-mode prefix
	@doc prefix <<<'switches mode to prefix prefix'
@fn prefix-help switch-mode prefix_help
	@doc prefix-help <<<'-> switch-mode prefix-help'

@@ quit-prefix
:: Restores previous mode '(â†’ quits prefixes)'
function quit-prefix {
	bf_d[mode]="$bckmode"
	unset bckmode
	redraw-statusline
}

@@ read-command
:: Works like normal "'read'" but for bottom commanline
function read-command {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	read -re -p "$1" "$2" || return 1
}

### TODO: make this make sense

@@ make-render Creates syntax highlighting for currently visible lines
function make-render {
	make-render-area "${bf_d[base]}" $((bf_d[base] + bf_d[size-y] + bf_d[loc-y]))
}

@@ make-render-area
:: Creates syntax highlighting for lines from '$1' to '$2'
function make-render-area {
    local -i line="$1"
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	for ((l=syntaxline;l<${2};l++)); do
		((l > $2)) && break
		local -n linearray="${current_buffer}_syntax${syntaxline}"
		linearray=()
		bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
		((syntaxline++))
		line="$l"
		make-render-line-loop
	done
	IFS="$bckeIFS"
}
	
@@ make-render-line
:: Syntax highlights single line '$1'
:: Defaults to currently selected line if no argument is passed
function make-render-line {
	local -i line=${1:-bf_d[line]}
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	make-render-line-loop
	IFS="$bckeIFS"
}



@@ make-render-line-loop
:: Backend for make-render-area \& make-render-line
:: Also creates bf_e charmap for movenment
:+     "Tab is 't'"
::     "Space is 's'"
::     "Any unmaped char is '0'"
function make-render-line-loop {
	local -i comment=0
	local -i skip_next_space=0
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	while read -rsn1 char; do	
		case "$char" in
			' ')
				syntax-word
				word=''
				((skip_next_space==1)) && skip_next_space=0 && continue
				bf_e[line]+='s'
				face-no-expand "${facename:-default}" ' '
				((column++));;
			'	')
				syntax-word
				word=''
				local -i i
				for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
					bf_e[line]+="${charmap[	]}"
				done
				face-no-expand tab-face "${options[tabchar]}"
				((column+=${#options[tabchar]}));;
			'')
				syntax-word
				word=''
				skip_next_space=0
				face-no-expand default ' '
				newline=1 # tell syntax functions that the previous char was newline # used for format thing
				return;;
			*)
				word+="${char}"
		esac
	done  <<< "${buffer[line]}"
}

@@ syntax-word
:: Decides what a word should highlighted as:
:+     'If todonote option is enabled, highlight "NOTE:" & "TODO:"'
::     'If the word is supposed to be comment highlight it as it'
::     'Else pass it to current syntax function'
function syntax-word {
	(("${options[todonote]}"==1)) && {
		case "$word" in
			'NOTE:') face NOTE "${word}"; return ;;
			'TODO:') face TODO "${word}"; return ;;
		esac
	}
	((comment)) && set-face font-lock-comment-face ||
		"${bf_d[syntax]}"
	((bf_d[syntax-exec])) || face "$syntax_face" "$word" # s_ex controls syntax extended
}

@@ face
:: Add highlighted word to multidimensional nonsense "'bf_s'" arry
function face {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
	for ((iw=0; iw < ${#2}; iw++)); do
		bf_e[line]+='0'
	done
}

@@ face-no-expand
:: Add highlighted word to multidimensional nonsense "'bf_s'" arry without adding anything to bf_e[] array
function face-no-expand {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
}

@@ set-face Sets face for syntax highlighting
@fn set-face 'syntax_face="$1"'

@@ size-full
:: Sets size of buffer to be fullscreen
function size-full {
	bf_d+=(
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$((LINES - 1))
	)
}

@@ set-buffer
:: Switch to buffer \$1 
function set-buffer {
	log info "switch to buffer [$1]"
	current_buffer="$1"
	declare -ng buffer="${current_buffer}_buffer"
	declare -ng bf_s="${current_buffer}_bf_s"
	declare -ng bf_e="${current_buffer}_bf_e"
	declare -ng bf_d="${current_buffer}_bf_d"
	declare -ng bf_c="${current_buffer}_bf_c"
}

@@ add-to-list
:: Adds a buffer into currently active buffer list
function add-to-list {
	log info "added into buffer list: $current_buffer"
	buffers_l+=("$current_buffer")
}

@@ clear-buffer
:: Empties buffer bf_s bf_e \& bf_d
function clear-buffer {
	buffer=()
	for l in "${bf_s[@]}"; {
		unset "$l"
	}
	bf_s=()
	bf_e=()
	for l in "${bf_c[@]}"; {
		unset "$l"
	}
	bf_c=()
}

@@ list-directory
:: Basically like ls command
	:: '    If' \$hidden is 1 also show hidden files 
	:: '    If' \$hidden is 0 also show the special .. 
function list-directory {
	((hidden==0)) && printf '..\n' || printf '%s\n' .*
	printf '%s\n' *
}

@@ current-time
:: Basically like coreutil "'date'"
@fn current-time 'printf "%($1)T\\n"'

@@ log
:: Adds message into log
:: '    info -- everything *should* be well'
:: '    warn -- something is wrong but it *should* not break entire Ebashs'
:: '    error -- something is wrong and anything can break, but it *can* still run(?)'
:: '    fatal -- something is mega wrong and only thing left to do is to die'
:: Is disabled when log wasn\'t initialised, see init-log for info
function log {
	((log)) || return
	local type="$1"
	shift
	tooktime="$(( $(current-time '%s') - lasttime ))"
	bufferlog+=("<f> title [$type] </f> <f> font-lock-comment-face ${tooktime}s </f> <f> name [${FUNCNAME[1]}] </f> $*")
	lasttime="$(current-time '%s')"
}

@@ log-echo
:: Adds message into log without any special formating	
function log-echo {
	((log)) || return
	bufferlog+=("<f> font-lock-comment-face > </f>    $*")
}

## debug
# +debug -- basically like set -x but reports stuff into log
@@ +log	
:: Debug function to add logging to function it\'s called from
function +log {
	((log)) || return
	((options[log-functions])) && log '*' "${FUNCNAME[1]}"
	trap 'log bash $? $LINENO ${BASH_COMMAND}' ERR
}
@@ +debug
:: Debug function to add extensive \(set -x like\) logging to function it\'s called from
function +debug {
	((log)) || return
	trap 'log DEBUG "${BASH_COMMAND}"' DEBUG
}

@@ goto Load array into buffer
function goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
	copy-array "$1" buffer
	redraw
}

@doc syntax-format <<'EOF'
Convert formated text into Ebashs buffer understandable format.

<f> title <u> Specifications </u> </f>

<[> name <f> <f> hint face_name text... </f> <[> name </f>
<-> Set <f> hint text </f> to face <f> hint face_name </f-> .

<[> name <h> <f> hint text... </f> <[> name </h>
<-> Make <f> hint text </f> into title.

<[> name <a> <f> hint command </f> <[> name : <f> hint text </f> <[> name </a>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> See <a> doc-goto link-enter : <f> link link-enter </f> </a> 

<[> name <link> <f> hint command </f> <[> name : <f> hint text </f> <[> name </link>
<-> Create clickable area that executes <f> hint command </f> on click and is labeled <f> hint text </f-> .
<-> <[> name <link> also automatically adds <f> link link </f> face to text.

<[> name <u> <f> hint text </f> <[> name </u>
<-> Make <f> hint text </f> <u> uppercase. </u>

<[> name <i> <f> hint number_of_spaces hint text </f-> ...\n...\n...\n... <[> name </i>
<i-tab> Indent lines by <f> hint number of spaces </f-> .

<[> name <i-tab>
<-> Indent by tab (default 4 spaces).
<-> Tab size is controlled via tab_format variable. </i>

<[> name <s> <f> hint number_of_spaces </f>
<-> Insert <f> hint number of spaces </f-> .

<[> name <tab>
<-> Insert tab.
<-> <[> name <-> is alias for <[> name <tab>.

<[> name <v> <f> hint variable_name </f> <[> name </v>
<-> Insert contents of <f> hint variable </f> into text at formating time.

<[> name <\> <f> hint text </f>
<-> Escape <f> hint text </f>

<[> name <[> <f> hint face_name text </f>
<-> Escape <f> hint text </f> with <f> hint face </f-> .


Some of these keywords also include versions to glue together with other words.
For example:
<-> text <[> name <-f> <f> name face </f> color! <[> name </f-> text
Will turn into text <-f> lr c <-f> ly o <-f> lg l <-f> lc o <-f> lb r <-f> lm ! </f> </f> </f> </f> </f> </f-> text.
EOF
function syntax-format {
	((skip_word==1)) && {
		skip_next_space=1
		[ "$word" = '-->' ] && skip_word=0
		return
	}
	[ "$word" = '<!--' ] && {
		skip_next_space=1
		skip_word=1
		return
	}
	((newline==1)) && {
		ichar="${indent_spaces}"
	}
	((newline==0)) && {
		ichar=
	}

	((escape==2)) && {
		escape=1
		facename="$word"
		skip_next_space=1
		return
	}
	((escape==1)) && {
		escape=0
		face "$facename" "${ichar}$word"
		return
	}
	[ "$word" = '<\>' ] && {
		escape=1
		skip_next_space=1
		facename='unknown'
		return
	}
	[ "$word" = '<[>' ] && {
		escape=2
		skip_next_space=1
		return
	}
	
	((variable==1)) && {
		variable=0
		word="${!word}"
	}
	[ "$word" = '<v>' ] && {
		variable=1
		varname=
		skip_next_space=1
		return
	}

	[ "$word" = '</u>' ] && {
		upper=0
		skip_next_space=1
		return
	}
	[ "$word" = '<u>' ] && {
		upper=1
		skip_next_space=1
		return
	}
	[ "$word" = '</f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '</f->' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		skip_next_space=1
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	((facedef==1)) && {
		skip_next_space=1
		facedef=0
		facename="$word"
		return
	}
	[ "$word" = '<f>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	[ "$word" = '<-f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	
	[ "$word" = '</h>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		upper=0
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<h>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=title
		upper=1
		return
	}
	
	((sethighlight==2)) && {
		sethighlight=1
		skip_next_space=1
		tmp_sex="$word"
		return
	}
	((sethighlight==1)) && {
		sethighlight=0
		skip_next_space=1
		bf_d[syntax-exec]="$tmp_sex"
		bf_d[syntax]="syntax-$word"
		return
	}
	[ "$word" = '<change-syntax>' ] && {
		skip_next_space=1
		sethighlight=2
		return
	}
	((space_next==1)) && {
		space_next=0
		skip_next_space=1
		for ((if=0; if< word; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '<s>' ] && {
		space_next=1
		skip_next_space=1
		return
	}
	[ "$word" = '<tab>' ] || [ "$word" = '<->' ] && {
		skip_next_space=1
		for ((if=0; if< format_tab; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '</i>' ] && {
		indent_spaces=
		return
	}
	((indent==1)) && {
		indent=0
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< word; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	[ "$word" = '<i>' ] && {
		indent=1
		skip_next_space=1
		return
	}
	[ "$word" = '<i-tab>' ] && {
		skip_next_space=1
		indent_spaces=
		indent_spaces_e=
		for ((if=0; if< format_tab; if++)) {
			indent_spaces+=' '
			indent_spaces_e+='s'
		}
		return
	}
	((link==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				link=1
			))
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</a>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		return
	}
	[ "$word" = '<a>' ] && {
		((
			link=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	((facelink==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				facelink=1
			))
			facename='link'
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</link>' ] && {
		((lc++))
		((column--))
		facelink=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<link>' ] && {
		((
			facelink=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	
	((object==1)) && {
		skip_next_space=1
		[ "$word" = 'text:' ] && {
			object=0
			set_obj=0
			return
		}
		[ "$word" = 'select:' ] && { set_obj=1; obj_select=; return; }
		[ "$word" = 'id:' ] && { set_obj=2; obj_id=; return; }
		[ "$word" = 'left:' ] && { set_obj=3; obj_left=; return; }
		[ "$word" = 'up:' ] && { set_obj=4; obj_up=; return; }
		[ "$word" = 'right:' ] && { set_obj=5; obj_right=; return; }
		[ "$word" = 'down:' ] && { set_obj=6; obj_down=; return; }

		((set_obj==1)) && obj_select+="$word "
		((set_obj==2)) && obj_id+="$word "
		((set_obj==3)) && obj_left+="$word "
		((set_obj==4)) && obj_up+="$word "
		((set_obj==5)) && obj_right+="$word "
		((set_obj==6)) && obj_down+="$word "
		return
	}
	[ "$word" = '</o>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$obj_select"
			[id]="$obj_id"
			[left]="$obj_left"
			[up]="$obj_up"
			[right]="$obj_right"
			[down]="$obj_down"
		)
		return
	}
	[ "$word" = '<o>' ] && {
		((
			object=1,
			lsx=column,
			skip_next_space=1
		))
		obj_id=
		obj_text=
		obj_select='true'
		obj_left='backward-char'
		obj_up='previous-line'
		obj_right='forward-char'
		obj_down='next-line'
		set_obj=0
		return
	}
	
	((newline==1)) && newline=0
	((column+=${#ichar} + ${#word}))
	((upper==1)) && {
		word="${word^^}"
	}
	face "${facename:-unknown}" "${ichar}$word"
}

@doc link-enter <<'EOF'
Executes <f> name clickable area </f> of formated text to which current position
of cursor points.
Mostly used for <f> name hyperlinks </f-> .

Internally <f> name clickable area </f> is defined via bf_c 2d array. Each line contains
the <f> name clickable areas </f-> . Each of these is it's own associative array.
Each <f> name clickable area </f> contains:
<i-tab> <[> hint start - the first column of the area
<[> hint end   - the last column of the area
<[> hint exec  - what command should be executed when this function,
<-> <f> name link-enter </f> is ran. </i>
EOF
function link-enter {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		#echo "    $link" >> d
		#echo "${bf_c_line[start]}" >> d
		#echo "${bf_c_line[end]}" >> d
		#echo "${bf_c_line[exec]}" >> d
		
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				has=1
				${bf_c_line[exec]}
				return
			}
	}
	${bf_d[format-else]}
}

function format-left {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[left]:-backward-char}
				return
			}
	}
	backward-char
}
function format-up {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[up]:-previous-line}
				return
			}
	}
	previous-line
}
function format-right {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[right]:-forward-char}
				return
			}
	}
	forward-char
}
function format-down {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[down]:-next-line}
				return
			}
	}
	next-line
}

function obj {
	for y in "${!bf_c[@]}"; {
		for obj in ${bf_c[y]}; {
			local -n bf_c_line="$obj"
			[ "${bf_c_line[id]}" = "$1 " ] && {
				((bf_d[line]=y, bf_d[column]=bf_c_line[start]))
				redraw-cursor
			}
		}
	}
}
	
@fn is-function 'declare -F -- "$1" > /dev/null'

defun dump-buffer
	:: Dumps current buffer into a file	
	function = {
			true >"$1" # Set the file to an empty text file
			for ln in "${buffer[@]}"; do # Write in the buffer to the file
				echo "$ln" >>"$1"
			done
	}

defun die
	:: Closes Ebashs with exit code \$errno, if errno is empty exit with 0
	:: If \$nocleanup is 1, do not restore the terminal to sane mode and do not cleanup 
	:: Else restore to sane mode 
	function = {
		((nocleanup)) && exit "${errno:-0}"
		echo -e "\e[?1000;1006;1015l" #disable mouse tracking
		clear-screen # TODO fix the buffer switching
		printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
		exit "${errno:-0}" # Assume that we are exiting without an error
	}

defun abort
	:: Sets \$nocleanup to 1 and dies	
	function = {
		((nocleanup=1)) && die "$@"
	}

fragment move <<< 'for ((i = 0; i < ${1:-1}; i++)); do'
fragment end <<< 'done'

fragment keepcolumn <<'+'
	[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
	(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
	(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
+

defun-fragment move-previous-line
	:: Moves up \$1 lines, if \$ is empty move up 1 line
	function = {
		@ move
			((bf_d[line] > 1)) && ((bf_d[line]--)) # As long as we can keep going up, go up
			((bf_d[line] < bf_d[base] + 1)) && {
				((bf_d[base]--)) # Push back the top if we need to
				move_base=1 # Send signal to redraw-cursor that the buffer was moved, thus needs to be redraw fully
				((bf_d[base] <= 0)) && bf_d[base]=1 # Don't push back if our base is at 1
			}
			@ keepcolumn
		@ end
	}

defun-fragment move-next-line
	:: Moves down \$1 lines, if \$ is empty move down 1 line
	function = {
		@ move
			((bf_d[line] < ${#buffer[@]}+1)) && ((bf_d[line]++)) # If we can go down, go down
			# Move window down if needed
			((bf_d[line] > bf_d[base] + bf_d[size-y] - 3 - bottomlines)) && {
				((bf_d[base]++))
				move_base=1
			}
			@ keepcolumn
		@ end
}
nufed

template move <<'+'
	function @var 1 {
		@var 2 @var 3 ;
		redraw-statusline;
		if ((bf_d[selection])); then
			redraw ;
		else
			redraw-cursor ;
		fi ;
	}
+
	@: previous-line move-previous-line '$@'
	@: next-line move-next-line '$@'
	@: scroll-down move-previous-line '$((bf_d[size-y] - 3))'
	@: scroll-up move-next-line '$((bf_d[size-y] - 3))'

@fn move-beginning-of-line 'bf_d[column]=0; redraw'
@fn move-end-of-line 'bf_d[column]="${#bf_e[${bf_d[line]}]}"; redraw'

fragment select <<'+'
    ((bf_d[selection])) || {
		bf_d[selection_start_y]="${bf_d[line]}"
		bf_d[selection_start_x]="${bf_d[column]}"
		bf_d[selection]=1
	}
+
template select <<<'function @var 1 { @ select; @var 2 ; } && @add @var 1'
	@: select-forward forward-char
	@: select-backward backward-char
	@: select-next next-line
	@: select-previous previous-line

fragment forwardcheck <<'+'
	((bf_d[column] > ${#bf_e[${bf_d[line]}]})) && {
		bf_d[column]=0
		next-line
		return
	 }
+
fragment backwardcheck <<'+'
	((bf_d[column] < 0)) && ((bf_d[line]==1)) && {
		bf_d[line]=1
		bf_d[column]=0
	}
	((bf_d[column] < 0)) && {
		bf_d[column]="${#bf_e[${bf_d[line]}-1]}"
		previous-line
		return
	}
+

template char <<'+'
	function @var 1 {
		@ move ;
			case "${bf_e[${bf_d[line]}]:${bf_d[column]} @var 2 1:1}" in
				't') bf_d[column]=$(( bf_d[column] @var 2 ${#options[tabchar]}));;
				*) ((bf_d[column] @var 3 ));;
			esac; @var 4 ; bckrl= ;
		@ end ;
		if ((bf_d[selection])); then
			redraw ;
		else
			redraw-cursor-line ;
		fi ;
	} && @add @var 1 ;
+
	@: forward-char + ++ '@ forwardcheck'
	@: backward-char - -- '@ backwardcheck'

@@ forward-word
:: Moves forward to next word
function forward-word {
	((bf_d[column] == ${#bf_e[bf_d[line]]})) && {
		next-line
		move-beginning-of-line
	}
	while :; do
		((bf_d[column] < ${#bf_e[bf_d[line]]})) && ((bf_d[column]++)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}

@@ backward-word
:: Moves backward to previous word
function backward-word {
	((bf_d[column] == 0)) && {
		previous-line
		move-end-of-line
	}
	while :; do
		((bf_d[column] > 0)) && ((bf_d[column]--)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}


@doc to-line <<'+'
Move cursor to line number $1 and move the line into middle of visible buffer area.
+
function to-line {
	bf_d[line]="$1"
	bf_d[base]=$((bf_d[line] - bf_d[size-y] / 2 ))
	redraw
}
			
defun menuline-mouse
	:: Handle clicking on top menu with mouse		
	function = {
		local -n top_0="menu_${bf_d[menuline]}_0"
		local -n top_1="menu_${bf_d[menuline]}_1"
		#determine which item should be triggered
		[ -z "$1" ] && menuloc_x=0 || menuloc_x=$1
		local cx="${bf_d[loc-x]}"
		i=0
		for i in "${!top_0[@]}"; {
			la="${#top_0[i]}"
			((menuloc_x>cx)) && ((menuloc_x<(cx + la + 1))) && {
				${top_1[$i]}
				return
			}
			cx=$(( cx + la + 1 ))
		}
	}

defun redraw-menu
	:: Redraw popup menu
	function = {
		printf '\e[?25l' # hide cursor (again)
		printf '\e[%s;0H' $menuloc_y
		for i in "${!menu_0[@]}"; {
			if ((i == menuselection)); then
				printf "\e[%sC${faces[menu-selected-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"  
			else
	   			printf "\e[%sC${faces[menu-enabled-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"
			fi
		}
	}
template menumove <<'+'
	function @var 1 {
		((menuselection @var 2 @var 3 )) && ((menuselection @var 4 ));
		redraw-menu;
	}
+
@: menuup '>' 0 '--'
@: menudown '<' '${#menu_0[@]} -1' '++'

defun menuselect
	:: Execute selected item in menu
	function =
		for i in "${!menu_1[@]}"; {
			((i == menuselection)) && "${menu_1[i]}"
		}

defun menuleave
	:: Closes a menu
	function = {
		ismenu=0
		bf_d[mode]="${modebackup}"
		redraw
	}

defun menu
	:: Opens a menu \$1	
	function = {
		declare -ng menu_0=menu_${1}_0
		declare -ng menu_1=menu_${1}_1
		((ismenu == 0 )) && modebackup="${bf_d[mode]}"
		ismenu=1
		declare -ig menuselection=0
		bf_d[mode]='menu'
		redraw
	}

defun delete-buffer
	:: deletes current buffer
	function = {
		local -a copy
		local i=0
		local index
		for b in "${buffers_l[@]}"
		do
			[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
			[[ "$b" = "$current_buffer"  ]] && index="$i"
			((i++))
		done
		unset buffers_l
		copy-array copy buffers_l
		current_buffer="${buffers_l[index-1]}"
		redraw
	}
						
defun selection-draw
	:: Draw multiline region
	function =
		if ((i == bf_d["${1}_y"])); then
			printf "${ln}%*s\e[%sG%b%s%b%s%b%b"\
				   ${lnargs[@]}\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   $((bf_d[loc-x] + bf_d[number-length] + space))\
				   "${faces[default]}"\
				   "${linearray[*]:bf_d[basecolumn]:bf_d[${1}_x]}"\
				   "\e[m${faces[region]}"\
				   "${buffer[i]:bf_d[${1}_x]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
				   "${faces[default]}" "$nlchar"
		elif ((i == bf_d["${2}_y"])); then
			printf "${ln}%*s\e[%sG%b%b%s%b%s%b%b"\
				   ${lnargs[@]}\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   $((bf_d[loc-x] + bf_d[number-length] + space))\
				   "${faces[default]}"\
				   "${faces[region]}"\
				   "${buffer[i]:bf_d[basecolumn]:bf_d[${2}_x]}"\
				   "\e[m"\
				   "${linearray[*]:bf_d[${2}_x]:bf_d[size-x]}"\
				   "${faces[default]}" "$nlchar"
		else
			printf "${ln}%*s\e[%sG%b%b%s%b%b"\
				   ${lnargs[@]}\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   $((bf_d[loc-x] + bf_d[number-length] + space))\
				   "${faces[default]}"\
				   "${faces[region]}" "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
				   "${faces[default]}" "$nlchar"
		fi

defun change-size-screen
	:: Handle changing size of terminal
	function = {
		bf_d[size-x]="$COLUMNS"
		bf_d[size-y]=$((LINES-1))
		redraw
	}
nufed
	
@@ redraw
:: Redraw screen
function redraw {
	[ -n "${bf_d[redraw]}" ] && {
		"${bf_d[redraw]}" "$@"
		return
	}
	printf '\e[?25l'

	# the first line should be always empty 
	unset buffer[0]
	
	# Handle changing size of buffer
	((bf_d[size-x]!=bcksize_x)) || ((bf_d[size-y]!=bcksize_y)) && {
		# Make the statusline full of dashes
		dashline=$(
			for ((i=0; i<bf_d[size-x]; i++)) {
				printf '-'
			}
		)
		bcksize_x=${bf_d[size-x]}
		bcksize_y=${bf_d[size-y]}
	}
		
	# Get length of line-number of lines
	bf_d[length]="${#buffer[@]}"
	((bf_d[length]==0)) &&((bf_d[length]++))
	
	((options[line-number-mode])) && {
		bf_d[number-length]=${#bf_d[length]}
		bf_d[number-space]=1
	} || ((bf_d[number-length]=0, bf_d[number-space]=0))
	
	# Update selection ends to current cursor
	((bf_d[selection]==1)) &&
		((bf_d[selection_end_y]=bf_d[line], bf_d[selection_end_x]=bf_d[column]))
	
	# Move the buffer horizontally if needed
	((bf_d[column] +3 < bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=0
	((bf_d[column] +3 > bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=$((bf_d[column] - (bf_d[size-x] + bf_d[loc-x] - bf_d[number-length] - 1) +3))

	# Draw top menuline
	(("${options[menu-line]}"==1)) && {
		redraw-menuline
	} || printf "\e[%s;%sH" "${bf_d[loc-y]}" "${bf_d[loc-x]}"

	# IFS has to be empty in order to bufferarray multiarray be printed as words instead of chars
	IFS=''

	# Handle line number displaying
	# the resulting line has to be printed in one go to prevent flicker
	# space stores if the position of actuall text should be offset by +1
	# ln stores printf print line
	# args stores printf arguments
	local -i space
	local ln
	local -a lnargs
	
	# Iterate over shown lines
	local -i max=$((bf_d[size-y] - (toplines + bottomlines) + 1))
	for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do
	# if the line is last, do not add newline

		if ((options[line-number-mode])); then
			space=1
			ln="\e[%dG%b%*s"
			lnargs=(
				"${bf_d[loc-x]}"
				"${faces[line-number]}"
				"${bf_d[number-length]}"
				"$i"
			)
			((i == bf_d[line])) && lnargs[1]="${faces[line-number-current-line]}"
		fi
		
		((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'

		((i > ${#buffer[@]})) &&
			printf '\e[%sG%b%*s%s%b%*s%b'\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-empty]}"\
				   $((bf_d[number-length]/2)) ''\
				   "${options[empty-line-char]}"\
				   "${faces[default]}"\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   "$nlchar" &&
			continue
		
		# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
		[ -z "${bf_s[base+i]}" ] && {
			make-render-line $((base + i))
		}
		local -n linearray="${bf_s[i]}"
		
		# draw the selection area
		((bf_d[selection])) && {
			((i == bf_d[selection_start_y])) &&
				((bf_d[selection_start_y] == bf_d[selection_end_y])) && {
					((bf_d[selection_start_x] <= bf_d[selection_end_x])) && {
						local -n sx=bf_d[selection_start_x]
						local -n ex=bf_d[selection_end_x]
					} || {
						local -n sx=bf_d[selection_end_x]
						local -n ex=bf_d[selection_start_x]
					}
					printf "${ln}%*s\e[%sG%b%s%b%s%b%s%b"\
						   ${lnargs[@]}\
						   $((bf_d[size-x] - bf_d[number-length]))\
						   ''\
						   $((bf_d[loc-x] + bf_d[number-length] + space))\
						   "${faces[default]}"\
						   "${linearray[*]:bf_d[basecolumn]:sx}"\
						   "\e[m${faces[region]}"\
						   "${buffer[i]:sx:ex-sx}"\
						   "\e[m"\
						   "${linearray[*]:ex:bf_d[size-x]}"\
						   "$nlchar"
					continue
				}
			((i >= bf_d[selection_start_y])) && ((i <= bf_d[selection_end_y])) && {
				selection-draw selection_start selection_end
				continue
			}
			((i <= bf_d[selection_start_y])) && ((i >= bf_d[selection_end_y])) && {
				selection-draw selection_end selection_start
				continue
			}
		}
		# due to escape codes present in bf_s,
		# the bf_s has to be multidimensional nonsense for perfomance reasons
		printf "${ln}%*s\e[%sG%b%s%b"\
			   ${lnargs[@]}\
			   $((bf_d[size-x] - bf_d[number-length]))\
			   ''\
			   $((bf_d[loc-x] + bf_d[number-length] + space))\
			   "${faces[default]}"\
			   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
			   "$nlchar"
	done
	redraw-statusline
	redraw-commandline
	((no_cursor)) || redraw-cursor		
	@ifs		
	# redraw menu if open
	[ "${bf_d[mode]}" = 'menu' ] && redraw-menu
}

@@ redraw-menuline Redraws top menu line
function redraw-menuline {
	local -n top_0="menu_${bf_d[menuline]}_0"
	printf "\e[0m\e[%s;%sH${faces[menu]}\e[?25l%*s\r%s"\
		   "${bf_d[loc-y]}"\
		   "${bf_d[loc-x]}"\
		   "${bf_d[size-x]}"\
		   "${bf_d[info]}"
	printf '\e[%sG%s\e[0m\n' "${bf_d[loc-x]}" "${top_0[*]}"
}

defun redraw-cursor-line
	:: Draw cursor on the line
	function = {
		((options[full-redraw]==0)) && {
			# redraw if buffer needs to be moved horizontally
			((bf_d[column] > bf_d[size-x] - bf_d[number-lenght] - space)) && {
				redraw
				return
			}
			((bf_d[basecolumn]==0)) || {
				redraw
				return
			}
			printf '\e[%sG\e[?25h'\
				   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space])) ||
				redraw
		}
	}
	
defun redraw-cursor
	:: Draw cursor and if move_base is 1 redraw
	function = {
		((options[full-redraw])) && {
			no_cursor=1
			redraw
			no_cursor=0
		}
		((move_base)) && {
			move_base=0
			redraw
			return
		}
		local -i y=$((bf_d[line] + options[menu-line] - bf_d[base] + bf_d[loc-y]))
		((options[line-number-mode])) && {
			printf '\e[%s;%sH%b%*s\e[m'\
				   $((last_line + options[menu-line] - bf_d[base] + bf_d[loc-y]))\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number]}"\
				   ${bf_d[number-length]}\
				   $last_line
			printf '\e[%s;%sH%b%*s\e[m'\
				   $y\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-current-line]}"\
				   ${bf_d[number-length]}\
				   ${bf_d[line]}
		}
		printf '\e[%s;%sH\e[?25h'\
			   $y\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
		last_line=${bf_d[line]}
	}

defun redraw-statusline
	:: Draw bottom mode/status line
	function = {
		((options[mode-line])) &&
			printf "\e[%s;%sH\e[%sG%b%s\e[%sG%s %b%s\e[m%b %d%% (%d,%d) (%s[%s]) (screen: %s) \e[m" \
				   $((bf_d[size-y] - 1 + bf_d[loc-y]))\
				   $((bf_d[size-x] + bf_d[loc-x]))\
				   "${bf_d[loc-x]}"\
				   "${faces[mode-line]}"\
				   "$dashline"\
				   "${bf_d[loc-x]}" \
				   "${bf_d[mode]}"\
				   "${faces[file-name]}"\
				   "$(base-name "${bf_d[file]}")"\
				   "${faces[mode-line]}"\
				   $((100 * bf_d[line] / bf_d[length]))\
				   "${bf_d[line]}"\
				   "${bf_d[column]}"\
				   "${highlight[${bf_d[filetype]}]}"\
				   "${bf_d[filetype]}"\
				   "$current_buffer"
	}

defun redraw-commandline
	:: Draw bottomest command line message echo area
	function = {
		# clear message if it has been printed before already
		((options[keep-message]==0)) && 
			((clrmsg)) && {
				message=
				clrmsg=0
			} || clrmsg=1
		if ((options[command-line])); then
			printf "\e[%s;%sH\n${faces[minibuffer-prompt]}%*s\r%s\e[m" \
				   $((LINES-1)) 1 $((COLUMNS)) ' ' "$message"
		else
			[ -n "$message" ] &&
				printf "\e[%s;%sH%s" \
					   $((LINES)) 1 "$message"
		fi
	}
nufed

@@ handle-mouse
:: Handle mouse click
function handle-mouse {
	local -i x y
	#parse mouse stuff somewhatish weirdly
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
	((skipnext==1)) && skipnext=0 && return
	((skipnext==0)) && [ "${k_hex[*]:0:2}" = '1b 5b' ] && {
		mapfile -t -d '' inputarray <<< "${1}"
		inputarray[-1]="${inputarray[-1]%?}"
		[ -z "${inputarray[2]}" ] && skipnext=1
		mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
		inputarray[-1]="${inputarray[-1]%?}"	
		mousemode="${inputarray[0]}"
		x="${inputarray[1]}"
		y="${inputarray[2]::-1}"
		#limitations of movenment
		#TODO:
		[ $y = "${bf_d[loc-y]}" ] && menuline-mouse $x && return #handle menuline
		((x < (bf_d[number-length] + bf_d[loc-x] + 2))) && {
			if [ "$mousemode" = '[<0' ]; then
				bf_d[line]=$(( bf_d[base] + ( (y - bf_d[loc-y]) - toplines) ))
				redraw
			elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
				clear-screen
				echo 'Enter the index: '
				read -re line
				redraw
			fi
			return
		}
		bf_d[line]=$(( bf_d[base] + ( y - bf_d[loc-y] - 1) ))
		bf_d[column]=$(( x - (bf_d[loc-x] + bf_d[number-length] + 1) ))
		((bf_d[line] > ${#bf_e[@]})) &&
			bf_d[line]=${#bf_e[@]}
		((bf_d[column] > ${#bf_e[bf_d[line]]})) &&
			bf_d[column]=${#bf_e[bf_d[line]]}
		redraw
	}
}
	
@@ input-key Handles input
:: Either \$1 raw character input or k_hex array containing hex values of characters is used
function input-key {
	#arg $1 is the pressed key in normal text form
	#k_hex is pressed key in hex array ending with 0
		
	local -i mode_contains=0
	local -n modekeys="keys_${bf_d[mode]}"\
	         key_options="key_options_${bf_d[mode]}"

	# global keys
	((key_options[disable-global])) ||
		for str in "${!keys_global[@]}"
		{
			[ "$str" = "${k_hex[*]}" ] && {
				"${keys_global[$str]}"
				return
			}
		}

	# Execute the 'always' key option
	((${#key_options[@]})) &&
		[ -n "${key_options[always]}" ] && "${key_options[always]}"

	# Loop over current mode keybindings to match current keypress
	for str in "${!modekeys[@]}"
	{
		[ "$str" = "${k_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	}

	# If mode keybinding doesn't contain current keypress, execute this
	((${#key_options[@]})) &&
		((mode_contains == 0)) &&
		[ -n "${key_options[else]}" ] && {
			[ "${key_options[else]}" = 'insert' ] || {
				"${key_options[else]}" && return
			}
		}

	# Do not continue if mode contains keypress to prevent control chars flooding file
	((mode_contains==1)) && return

	# If mouse is enabled, do whatever the hell that ugly piece of code does
	(("${options[mouse]}"==1)) && {
		handle-mouse "$1"
		return
	}

	# Insert the pressed character
	[[ $1 =~ [[:cntrl:]] ]] && return # If char is control char, return
	insert-word "$1"
}

function init-var {
	((options[log])) && init-log || unset buffer_log # set up log buffer (M-x log)


	log info setting traps...
	trap change-size-screen WINCH ALRM # Attach WINCH and ALRM to redraw the screen
	trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
	trap 'k_hex=(3 0); input-key' INT
	trap quit SIGTERM

	format_tab=4

	menuloc_y=0; menuloc_x=0 # menu positions
	log info 'Setting menu-line'
	toplines=${toplines:-0}
	((toplines=toplines + options[menu-line]))

	# this is reverse because the value is added to buffer redrawing size
	log info 'Setting mode-line'
	bottomlines=${bottomlines:-0}
	((options[mode-line]==0)) && ((bottomlines--))
	log info 'Setting command-line'
	((options[command-line]==0)) && ((bottomlines--))
	((bottomlines+=2))
	
	log-echo "toplines $toplines"
	log-echo "bottomlines $bottomlines"
	
	log info 'Setting reset'
	reset='\e[0;0m'
	log info 'Setting charmap'
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	if ((options[esc-to-meta])); then
		esc_timeout=123456789 # a very big number
	else
		esc_timeout=0.01
	fi
	log info 'Setting nlchar'
	nlchar='\n'
	printf '\e[?1049h'
	log info 'Setting mouse'
	((options[mouse])) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
}

@@ main Main keyboard loop
function main
	while :; do
		local -a k=()
		local -i i=1
		k_hex=() # Also convert the input sequence into hex for way easier handling
		# Check for ready input
		read -rsN1 k[0] && {
			k_hex[0]="$(printf "%x\n" "'${k[0]}")"

			# Hack to try preventing arrow codes being split into multiple and inserting garbage to buffer
			[ "${k_hex[0]}" = '1b' ] && {
				read -rsN1 -t "${esc_timeout}" k[1]
				k_hex[1]="$(printf "%x\n" "'${k[1]}")"
				[ "${k_hex[1]}" = '5b' ] && {
					read -rsN1 k[2]
					k_hex[2]="$(printf "%x\n" "'${k[2]}")"
					case "${k_hex[2]}" in
						'41'|'42'|'43'|'44')
							k_hex[3]='0'
							input-key "${k[@]}"
							continue
					esac
					i=2
				}
				((i++))
			}
			# Multibyte hack
			while read -rsN1 -t0.0001 k[$i]; do
				k_hex[$i]="$(printf "%x\n" "'${k[$i]}")"
				((i++))
			done
			k_hex[$i]='0'
			input-key "${k[@]}" # Handle keypress event
		}
	done
	
