#!/bin/bash
version="0.6.8"
# Ebashs: text editor written in pure bash powered by murky logic and mess
shopt -s lastpipe # For syntax
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize; (:;:) # Enable and then trigger a terminal size refresh
trap redraw WINCH ALRM # Attach WINCH and ALRM to redraw the screen
trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
trap 'input_hex=(3 0); handle-hex' INT
trap quit SIGTERM

declare -A syntax faces options charmap commands
declare -A menulineedit diredmenu menulinedebug
declare -A menufancy
declare -A keys_def keys_global
declare -a input_hex overlay listbuffers
declare -n buffer buffersyntax bufferexpand bufferdata
declare -i menulinep menulinepy toplines bottomlines hidden ismenu comment current_count
declare -n menucon
declare message reset readin

function load-default-config {
	### Config options
	## General options
	options=(
		[mouse]=0
		[todonote]=1
		[menuline]=1
		[tabchar]='‚îÇ   '
		[file_prompt]='Path: '
		[command_prompt]='M-x '
		[cancelhex]='18 0'
		[default_mode]='edit'
		[help_message]='(F10 to open menu)'
		[dired_message]='Pick a file'
		[render_chunk]=8
		[tile_mode]='vertical'
		[log]=0
		[log_functions]=0
	)
	## Key bindings configuration
	#      A keybindings for a mode x have to be in associative array named keys_${x}, else Ebashs won't see them
	#      keys_def is special case containing the common definitions.
	#      Function @kbd field is equivalent to ${keys_def[field]} but nicer
	#
	#      Kdeybindings are supplied in hexadecimal format(with ' 0' added as suffix.
	#      Function kbd provides Emacsy keybinding syntax.
	#
	#      A options for the keybings of given mode are defined by ass. array named key_options_${x}
	#          [else] option defines what should happen if the input wasn't any of keys defined in keybings
	keys_def=(
		[previous-line]='1b 5b 41 0'
		[next-line]='1b 5b 42 0'
		[forward-char]='1b 5b 43 0'
		[backward-char]='1b 5b 44 0'
		[scroll-down]='1b 5b 35 7e 0'
		[scroll-up]='1b 5b 36 7e 0'
		[select]='0'
	)
	
	global-set-key "$(kbd C-x)" 'prefix'
	global-set-key "$(kbd M-x)" 'execute-extended-command'
	global-set-key '1b 5b 32 31 7e 0' 'menulinemenu'
	global-set-key "$(kbd C-g)" 'quit-prefix'

	add-mode edit
	{
		local-set-key "$(@kbd previous-line)" 'previous-line'
		local-set-key "$(@kbd next-line)" 'next-line'
		local-set-key "$(@kbd forward-char)" 'forward-char'
		local-set-key "$(@kbd backward-char)" 'backward-char'
		local-set-key "$(@kbd scroll-down)" 'scroll-down'
		local-set-key "$(@kbd scroll-up)" 'scroll-up'
		local-set-key '1b 5b 31 3b 32 41 0' 'select-previous'
		local-set-key '1b 5b 31 3b 32 42 0' 'select-next'
		local-set-key '1b 5b 31 3b 32 43 0' 'select-forward'
		local-set-key '1b 5b 31 3b 32 44 0' 'select-backward'
		local-set-key '1b 20 0' 'set-mark-command' # in gnu emacs this is C-SPC but i cant get that to be detected in bash so M-SPC will suffice
		local-set-key "$(kbd C-h)" 'prefix-help'
		local-set-key "$(kbd C-p)" 'previous-line'
		local-set-key "$(kbd C-n)" 'next-line'
		local-set-key "$(kbd C-f)" 'forward-char'
		local-set-key "$(kbd M-f)" 'forward-word'
		local-set-key "$(kbd C-b)" 'backward-char'
		local-set-key "$(kbd M-b)" 'backward-word'
		local-set-key '10 0' 'scroll-down'
		local-set-key '16 0' 'scroll-up'
		local-set-key '0' 'newline'
		local-set-key "$(kbd C-l)" 'newline'
		local-set-key "$(kbd C-t)" 'execute'
		local-set-key "$(kbd C-d)" 'delete-line'
		local-set-key '7f 0' 'backspace'
		local-set-key '1b 5b 33 7e 0' 'delete'
		local-set-key "$(kbd M-g)" 'menukey'
		local-set-key "$(kbd C-a)" 'move-beginning-of-line'
		local-set-key '1b 5b 48 0' 'move-beginning-of-line'
		local-set-key "$(kbd C-e)" 'move-end-of-line'
		local-set-key '1b 5b 46 0' 'move-end-of-line'
	}
	
	add-mode dired
	{
		local-set-key "$(@kbd previous-line)" 'previous-line'
		local-set-key "$(@kbd next-line)" 'next-line'
		local-set-key "$(@kbd forward-char)" 'forward-char'
		local-set-key "$(@kbd backward-char)" 'backward-char'
		local-set-key "$(@kbd scroll-down)" 'scroll-down'
		local-set-key "$(@kbd scroll-up)" 'scroll-up'
		local-set-key "$(@kbd select)" 'dired-select'
		local-set-key "$(kbd h)" 'toggle_hidden'
	}
	
	add-mode view
	{
		local-set-key "$(@kbd previous-line)" 'previous-line'
		local-set-key "$(@kbd next-line)" 'next-line'
		local-set-key "$(@kbd forward-char)" 'forward-char'
		local-set-key "$(@kbd backward-char)" 'backward-char'
		local-set-key "$(@kbd scroll-down)" 'scroll-down'
		local-set-key "$(@kbd scroll-up)" 'scroll-up'
		local-set-key "$(@kbd select)" 'quit-view'
	}
	
	add-mode list_buffers
	{
		local-set-key "$(@kbd previous-line)" 'previous-line'
		local-set-key "$(@kbd next-line)" 'next-line'
		local-set-key "$(@kbd scroll-down)" 'scroll-down'
		local-set-key "$(@kbd scroll-up)" 'scroll-up'
		local-set-key "$(@kbd select)" 'quit-view'
	}
	key_options_list_buffers=(
		[else]='quit-view'
	)
	
	add-mode prefix
	{
		local-set-key "$(kbd C-c)" 'quit'
		local-set-key "$(kbd C-s)" 'write_buffer'
		local-set-key "$(kbd C-f)" 'find-file'
		local-set-key "$(kbd C-b)" 'list-buffers'
		local-set-key '62 0' 'switch-to-buffer'
		local-set-key '30 0' 'delete-window'
		local-set-key "$(kbd u)" 'undo'
	}
	key_options_prefix=(
		[always]='quit-prefix'
	)
	
	add-mode prefix_help
	{
		local-set-key '1 0' 'about'
		local-set-key '72 0' 'manual'
	}
	
	add-mode menu
	{
		local-set-key "$(@kbd previous-line)" 'menuup'
		local-set-key "$(@kbd next-line)" 'menudown'
		local-set-key "$(@kbd select)" 'menuselect'
	}
	key_options_menu=(
		[else]='menuleave'
	)
	
	## Faces
	#      Defined in escape codes
	#      Helper functions, see extensions/gruvboxdark for example
	faces=(
		[default]='\e[m'
		[TODO]='\e[0;97;45m'
		[NOTE]='\e[0;97;100m'
		[menu]='\e[100m'
		[menu-enabled-face]='\e[0;37;40m'
		[selected]='\e[30;45m'
		[link]='\e[94m'
		[menu-selected-face]='\e[30;45m'
		[mode-line]='\e[100m'
		[line-number]='\e[0;90m'
		[line-number-empty]='\e[0;90m'
		[line-number-current-line]='\e[0;91m'
		[tab-face]='\e[0;90m'
		[region]='\e[1;100m'
		[minibuffer-prompt]='\e[m'
		# ansi colors
		[ansi-color-black]='\e[40m'
		[ansi-color-blue]='\e[44m'
		[ansi-color-bold]='\e[1m'
		[ansi-color-bright-black]='\e[100m'
		[ansi-color-bright-blue]='\e[104m'
		[ansi-color-bright-blue]='\e[106m'
		[ansi-color-bright-blue]='\e[102m'
		[ansi-color-bright-blue]='\e[105m'
		[ansi-color-bright-blue]='\e[101m'
		[ansi-color-bright-blue]='\e[107m'
		[ansi-color-bright-blue]='\e[103m'
		[ansi-color-cyan]='\e[46m'
		[ansi-color-green]='\e[42m'
		[ansi-color-inverse]='\e[7m'
		[ansi-color-italic]='\e[3m'
		[ansi-color-magenta]='\e[45m'
		[ansi-color-red]='\e[41m'
		[ansi-color-underline]='\e[4m'
		[ansi-color-white]='\e[47m'
		[ansi-color-white]='\e[43m'
		# syntax highlighting
		[font-lock-variable-string-face]='\e[0;36;48m'
		[font-lock-comment-face]='\e[3;37;48m'
		[font-lock-variable-name-face]='\e[0;96m'
		[font-lock-argument-face]='\e[0;93m'
		[font-lock-flow-face]='\e[0;93m'
		[font-lock-pipe-face]='\e[1;94m'
		[font-lock-bracket-face]='\e[1;95m'
		[font-lock-constant-face]='\e[0;92m'
		[font-lock-string-face]='\e[0;32m'
		[font-lock-assign-face]='\e[0;94;108m'
		[font-lock-function-name-face]='\e[0;30;44m'
		[font-lock-keyword-face]='\e[0;91m'
		[font-lock-declare-face]='\e[0;31m'
	)

	## Commands
	#		List of commands for M-x.
	commands=(
		[quit]='quit'
		[newline]='newline'
		[set-buffer-file]='find-file'
		[read-file]='read-buffer'
		[write-file]='write-buffer'
		[delete-line]='delete-line'
		[toggle-mouse]='toggle-mouse'
		[execute]='execute'
		[shell]='shell'
		[force-quit]='die'
		[die]='die'
		[about]='about'
		[backspace]='backspace'
		[menu]='menu'
		[menul]='menulinemenu'
		[input]='inputcodes'
		[scroll-up]='scroll-up'
		[scroll-down]='scroll-down'
		[dired]='dired'
		[switch-to-buffer]='switch-to-buffer'
		[list-buffers]='list-buffers'
		[tile]='tile-buffers'
		[vertical]='tile-vertical'
		[horizontal]='tile-horizontal'
		[single]='tile-single'
		[log]='view-log'
		[list-faces-display]='list-faces-display'
	)

	function menulinemenu {
		declare -ng menucon=menufancy
		#menulinepy=$(( bufferdata[size_y] - ${#menufancy[@]} ))
		menu
	}
	menulineedit=(
		[File]=menu-file	[Help]=menu-help
		[Keys]=menu-key	    [Redraw]=refresh
		[Debug]=menu-debug
	)
	add-menu file
	menu_file=(
		[        MENU        ]=menulinemenu
		[Quit        C-x C-c ]="quit"
		[Visit file  C-x C-f ]="find-file"
		[Execute         C-t ]="execute"
		[Save        C-x C-s ]="write-buffer"
		[File picker         ]="dired"
	)
	add-menu help
	menu_help=(
		[        MENU        ]=menulinemenu
		[Keybinding          ]=menukey
		[About               ]=about
	)
	add-menu key
	menu_key=(
		[        MENU        ]=menulinemenu
		[Exit        C-x C-c ]="quit"
		[New Line    C-l | ‚èé ]="newline"
		[Set target      M-r ]="find-file"
		[Visit file  C-x C-f ]="read-buffer"
		[Save file   C-x C-s ]="write-buffer"
		[Delete Line     C-d ]="delete-line"
		[Prev Line       C-p ]="previous-line"
		[Next Line       C-n ]="next-line"
		[Prev Page       C-y ]="scroll-down"
		[Next Page       C-v ]="scroll-up"
		[Execute         C-t ]="execute"
		[Shell           C-s ]="shell"
		[Force exist     M-q ]="die"
	)
    add-menu debug
	menu_debug=(
		[   MENU   ]=menulinemenu
		[clear     ]=clear-screen
		[refresh   ]=refresh
		[backspace ]=backspace
		[right     ]=forward-char
		[left      ]=backward-char
		[inputcodes]=inputcodes
		[faces     ]=list-faces-display
	)

	syntax=(
		[bash]=syntax-bash	[sh]=syntax-bash
		[ksh]=syntax-bash	[mksh]=syntax-bash
		[dash]=syntax-bash	[zsh]=syntax-bash
		[conf]=syntax-config	[unknown]=syntax-unknown
		[i*dired]=dired-render
	)

	diredmenu=(
		[toggle hidden \(h\)]="toggle_hidden"
	)
}

## source extensions here
# source extensions/evil
## rest of this garbageware

# fragments act basically like macros but with cooler name
# see redraw-buffer function for example usage
function fragment {
	declare -ag "_fragment_$1"
	mapfile "_fragment_$1"
}
function @add {
	local -a _add_fn
	local -a _add_nfn
	local -i _add_f
	local -i _add_hf
	local _add_nfnline
	mapfile _add_fn < <(declare -f "$1")
	for _add_l in "${!_add_fn[@]}"; do
		bckIFS="$IFS"
		IFS=' '
		_add_f=0
		_add_hf=0
		_add_nfnline=
		for _add_w in ${_add_fn[_add_l]}; do
			if [ "$_add_w" = '@' ]; then
				_add_f=1
			elif ((_add_f)); then
				_add_f=0
				_add_hf=1
				local -n _add_fragment="_fragment_${_add_w//[^[:alnum:]]/}"
				for _add_l1 in "${!_add_fragment[@]}"; do
					_add_nfnline+=" ${_add_fragment[_add_l1]}"
				done
			else
				_add_nfnline+=" $_add_w"
			fi
		done
		((_add_hf)) || _add_nfn+="${_add_fn[_add_l]}"
		((_add_hf)) && _add_nfn+="$_add_nfnline"
	done
	eval "${_add_nfn[*]}"
	IFS="$bckIFS"
}

# templates allow creating functions with code changes with minimal code
# @def creates function from teplate
# @def <template_name> <@var 1> <@var 2>...
# @: creates function from last defined template
# @: <@var 1> <@var 2>...
function template {
	_last_template="$1"
	declare -g "_template_$1"
	local -n tpl="_template_$1"
	tpl=$(</dev/stdin)
}
function @def {
	local -n _tpl="_template_$1"
	local _fn
	local -i _n=0
	shift
	for _w in $_tpl; do
		case "$_w" in
			'@var')
				_n=1;;
			*)
				((_n)) && {
					_n=0
					_fn+="${!_w} "
					continue
				}
				_fn+="$_w "
			esac
	done
	eval "$_fn"
}
function @: { @def "$_last_template" "$@"; }

# unbashing bash one step at time ¬∞o¬∞

function _ {
	# this function is here to simplify stuff as writing overlong variables indexed by overloong variable index...
	# ...is quite tiring <3
	[ -z "$1" ] && {
		for n in "${refalias[@]}"; do
			unset "$n"
		done
		unset refalias
		return
	}
	declare -gn "$1"="$2"
	refalias+=("$1")
}
function __ {
	# swap two references
	local -n _swap_1="$1"
	local _swap_copy_1="${!_swap_1}"
	local -n _swap_2="$2"
	local _swap_copy_2="${!_swap_2}"
	declare -gn "$1"="${_swap_copy_2}"
	declare -gn "$2"="${_swap_copy_1}"
}

# A univeral function to copy both normal and associative arrays
function copy-array {
	local -n source="$1"
	local -n target="$2"
	target=()
	for idx in "${!source[@]}"; do
		target[idx]="${source[idx]}"
	done
}

# convert hex notation to escape code
template setface <<'+'
	function @var 1 {
		[ -z "$1" ] && return;
		case "${1::1}" in
			'#')
				r="${1:1:2}";
				g="${1:3:2}";
				b="${1:5:2}";
				printf '\\e[%s;2;%s;%s;%sm' @var 2 "$((16#$r))" "$((16#$g))" "$((16#$b))";;
		esac;
		shift;
		[ -n "$1" ] && "$@";
}
+
@: :foreground 38
@: :background 48

function kbd {
	local -i i=0
	local out
	local in
	local -i ch=1
	# Surely there is better solution...
	case "$1" in
		C-a) printf '1 0' ;; C-b) printf '2 0' ;;
		C-c) printf '3 0' ;; C-d) printf '4 0' ;;
		C-e) printf '5 0' ;; C-f) printf '6 0' ;;
		C-g) printf '7 0' ;; C-h) printf '8 0' ;;
		C-i) printf '9 0' ;; C-j) printf 'a 0' ;;
		C-k) printf 'b 0' ;; C-l) printf 'c 0' ;;
		C-m) printf 'd 0' ;; C-n) printf 'e 0' ;;
		C-o) printf 'f 0' ;; C-p) printf '10 0';;
		C-q) printf '11 0';; C-r) printf '12 0';;
		C-s) printf '13 0';; C-t) printf '14 0';;
		C-u) printf '15 0';; C-v) printf '16 0';;
		C-w) printf '17 0';; C-x) printf '18 0';;
		C-y) printf '19 0';; C-z) printf '1a 0';;
		*)  ch=0
			case "${1:0:2}" in
				M-) in="${1:2:1}";;
				*) in="$1"
			esac
	esac
	((ch)) && return
	echo "$in" | {
		while read -rsn1; do
			out+="$(printf "%x\n" "'${in:$i}") "
			((i++))
		done
	}
	out=${out::-1}
	printf '%s' "${out}"
}
function @kbd {
	printf '%s' "${keys_def[$1]}"
}

function define-key {
	local -n keys="keys_$1"
	keys["$2"]="$3"
}
function local-set-key {
	define-key "$_last_keys" "$@"
}
function global-set-key {
	define-key global "$@"
}

function clear-screen {
	printf "\033c" # clear
}

function add-mode {
	# log TODO fix
	_last_keys="$1"
	declare -Ag "keys_$1"
	declare -Ag "key_options_$1"
}
function add-menu {
	# create new menu function & array
	eval "function menu-${1} { declare -ng menucon=menu_${1}; menu; }"
	declare -Ag "menu_${1}"
}

function refresh {
	clear-screen
	message="reloaded..."
	make-render
	redraw
	message=
}
function switch-mode {
	bckmode="${bufferdata[mode]}"
	bufferdata[mode]="$1"
	redraw-statusline
}
function prefix {
	switch-mode prefix
}
function prefix-help {
	switch-mode prefix_help
}
function quit-prefix {
	bufferdata[mode]="$bckmode"
	unset bckmode
	redraw-statusline
}
function read-command {
	printf '\e[%s;0H' $((bufferdata[size_y] + bufferdata[position_y]))
	printf '\e[?25h'
	read -re -p "$1" "$2" || return 1
}
function execute-extended-command {
	read-command "${options[command_prompt]}" readin || return 1
	for lcmd in "${!commands[@]}"; {
		[ "$readin" = "$lcmd" ] && "${commands[$lcmd]}"
		redraw
	}
}
### TODO: make this make sense
function save {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	savedcurrent_buffer="$current_buffer"
}
function restore {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	set-buffer "${savedcurrent_buffer}"
}
###

function get-syntax {
	for syntax_setting in "${!syntax[@]}"; do
		[ "$syntax_setting" = "${bufferdata[filetype]}" ] && {
			syntax_function="${syntax[$syntax_setting]}"
			return 0
		}
	done
	syntax_function="${syntax[unknown]}"
}

function make-render {
	((bufferdata[raw])) ||
		make-render-area "${bufferdata[base]}" $((bufferdata[base] + bufferdata[size_y] + bufferdata[position_y]))
}

fragment setrender <<'+'
	line="$1"
	((bufferdata[raw])) && return
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=''
	get-syntax
+

function make-render-area {
	@ setrender
	for ((l=syntaxline;l<${2};l++)); do
		((l > $2)) && break
		local -n linearray="${current_buffer}_syntax${syntaxline}"
		linearray=()
		buffersyntax[syntaxline]="${current_buffer}_syntax${syntaxline}"
		((syntaxline++))
		line="$l"
		make-render-line-loop
	done
	IFS="${bckeIFS}"
} && @add make-render-area

function make-render-line {
	((${#1})) || local -i line=${bufferdata[line]} ||
	@ setrender
	make-render-line-loop
	IFS="${bckeIFS}"
} && @add make-render-line

function expand-char {
	bckIFS="${IFS}"
	IFS=
	while read -rsn1 char
	do
		[ -z "$char" ] && echo && continue
		case "${char}" in
			'	')
				local -i i
				for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
					printf '%s' "${charmap[	]}"
				done;;
			' ') printf '%s' "${charmap[ ]}";;
			*)
				printf '0';;
		esac
	done
	IFS="${bckIFS}"
}

function make-render-line-loop {
	bufferexpand[line]="$(expand-char <<< "${buffer[line]}")"
	comment=0
	local word=''
	while read -rsn1 char
	do
		case "$char" in
			' ')
				syntax-word
				word=''
				face default ' '
				continue;;
			'	')
				syntax-word
				word=''
				face tab-face "${options[tabchar]}"
				continue;;
			'')
				syntax-word
				word=''
				face default ' '
				return;;
		esac
		word="${word}${char}"
	done  <<< "${buffer[line]}"
}

function syntax-word {
	(("${options[todonote]}"==1)) && {
		case "$word" in
			'NOTE:') face NOTE "${word}"; return ;;
			'TODO:') face TODO "${word}"; return ;;
		esac
	}
	"$syntax_function"
	face "$syntax_face" "$word"
}	
function face {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("$(printf '%b' "\e[0;0m${faces[${1}]}")${BASH_REMATCH[@]:1}")
	IFS=''
}
function set-face {
	syntax_face="$1"
}
function syntax-bash {
	((comment)) && set-face font-lock-comment-face && return
	case "${word}" in
		*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
		'"$'*) set-face font-lock-variable-string-face;;
		'#'*) set-face font-lock-comment-face && comment=1;;
		'$'*) set-face font-lock-variable-name-face;;
		'-'*) set-face font-lock-argument-face;;
		*'()') set-face font-lock-function-name-face;;
		'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
		'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
		'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
		'function') set-face font-lock-function-name;;
		*"'"*) set-face font-lock-constant-face;;
		*'"'*) set-face font-lock-string-face;;
		*'='*) set-face font-lock-assign-face;;
		'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
			'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
			'let'|'shopt'|'trap'|'set'|'eval'\
			) set-face font-lock-keyword-face;;
		*) set-face default;;
	esac
}
function syntax-unknown {
	set-face default
}
function dired-render {
	[ -d "$word" ] && set-face link
	[ -f "$word" ] && set-face default
}
function syntax-config {
	((comment)) && set-face font-lock-comment-face && return
	case "${word}" in
		'#'*) set-face font-lock-comment-face && comment=1;;
		   *) set-face default;;
	esac
}


add-mode debuginput
keys_debuginput=(
	[18 0]='quit-debuginput'
)
key_options_debuginput=(
	[else]='insert-debug-hex'
)


function base-name {
	for file in "$@"; do
	    file="${file%/}"
	    printf '%s\n' "${file##*/}"
	done
}
function filetype {
	#very ugly, TODO: redo this
	local filename shebang extension
	local -a filenamesplit shebangsplit
	[ $# = 0 ] && return
	local bckIFS="$IFS"
	IFS='.'
	filename="${1%/}"
	filename="${filename##*/}"
	[ "$filename" = 'COMMIT_EDITMSG' ] && echo conf && return
	filenamesplit=($filename)
	extension="${filenamesplit[-1]}"
	[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
	mapfile -n 1 file_data < "$1"
	shebang="$(echo -n "${file_data[@]}")"
	case "${shebang:0:1}" in
		'#')
		shebang="${shebang%/}"
		IFS=' '
		shebangsplit=("${shebang##*/}")
		local shebangss=(${shebangsplit[-1]})
		case "${shebangss[0]}" in
			env)
				printf '%s\n' "${shebangss[1]}";;
			*)
				printf '%s\n' "${shebangsplit[-1]}";;
			esac
		;;
		'!')
			mapfile -d ' ' -t split <<< "${shebang}"
			printf '%s\n' "${split[1]}"
			;;
		*) echo unknown
	esac
	IFS="${bckIFS}"
}

function find-file {
	printf '\e[%s;0H' $((bufferdata[size_y] + bufferdata[position_y]))
	printf '\e[?25h'
	bind 'set disable-completion off' 2>/dev/null # Enable completion
	read -re -p "${options[file_prompt]}" command && {
		read-buffer "$command"
		[ -n "$bckmode" ] && bufferdata[mode]="$bckmode" || bufferdata[mode]=edit
		redraw
	}
	bind 'set disable-completion on' 2>/dev/null

}

# draw something for nice transition
function draw-raw {( bufferdata[raw]=1; redraw )}

function size-full {
	bufferdata+=(
		[position_x]=1
		[position_y]=1
		[size_x]=$COLUMNS
		[size_y]=$((LINES - 1))
	)
}

function insert-debug-hex {
	buffer+=(
		"${input_hex[*]}"
	)
	next-line
	make-render-line
}

function set-buffer {
	log info "switch to buffer [$1]"
	current_buffer="$1"
	declare -ng buffer="${current_buffer}_buffer"
	declare -ng buffersyntax="${current_buffer}_buffersyntax"
	declare -ng bufferexpand="${current_buffer}_bufferexpand"
	declare -ng bufferdata="${current_buffer}_bufferdata"
}
function switch-to-buffer {
	redraw
	read-command "Switch to buffer: " readin
	set-buffer "$readin"
	redraw
}
add-to-list() {
	log info "added into buffer list: $current_buffer"
	listbuffers+=("$current_buffer")
}
function list-buffers {
	save openfile
	set-buffer list_buffers
	declare -Ag "${current_buffer}_bufferdata"
	copy-array overlay bckover
	overlay=()
	bufferdata=(
		[line]=1
		[base]=1
		[column]=0
		[modified]=0
		[info]='Currently open buffers'
		[mode]='list_buffers'
		[help_message]=''
		[filetype]='i*buffer-list'
		[file]='*Buffer List*'
		[raw]=1
		[menuline]='menulineabout'
	)
	menulineabout=(
		[quit]='quit-view'
	)
	copy-array listbuffers buffer
	redraw
}
function buffer-select {
	set-buffer "${buffer[bufferdata[line]]}"
	[ "${bufferdata[mode]}" = 'prefix' ] && bufferdata[mode]="$bckmode"
	redraw
}

function inputcodes {
	save openfile
	((current_count++))
	set-buffer "debuginput_${current_count}"
	add-to-list # add buffer to list of active buffers
	declare -Ag "${current_buffer}_bufferdata"
	bufferdata=(
		[line]=1
		[base]=1
		[column]=0
		[info]='Get input codes'
		[mode]='debuginput'
		[help_message]='C-x (18 0) to close'
		[filetype]='i*term'
		[file]='*debuginput*'
		[modified]=0
		[raw]=1
		[menuline]='menulinedebug'
	)
	size-full
	buffer=("")
	copy-array overlay bckover
	overlay=()
	menulinedebug=(
		[quit]='quit-debuginput'
	)
	clear-screen
	redraw
}
function quit-debuginput {
	copy-array bckover overlay
	restore openfile
	redraw
}

function read-buffer {
	log info "arg: $*"
	((current_count++))
	set-buffer "file_${current_count}"
	add-to-list
	declare -Ag "${current_buffer}_bufferdata"
	bufferdata=(
		[line]=0 # Currently selected line (0 means the buffer is empty)
		[base]=1 # Top-most line shown
		[column]=0 # Position of the cursor in $line
		[info]="${version}: insanity" # Feedback text in the status bar
		[mode]="${options[default_mode]}"
		[help_message]="${options[help_message]}"
		[filetype]="$(filetype "$1")"
		[file]="$1"
		[menuline]='menulineedit'
		[current_state]=0
	)
	size-full
	mapfile -t -O 1 "${current_buffer}_buffer" <"${bufferdata[file]}" # Read file into an array
	draw-raw
	#make-render # TODO: make fast
	if [[ "${buffer[*]}" ]]; then # Ensure that something was actually read into the file
		bufferdata[line]=1 # Indicate that we have a buffer loaded
		bufferdata[modified]=0
		bufferdata[info]="${bufferdata[file]}: ${#buffer[@]}"
	else
		bufferdata[info]="${bufferdata[file]}: empty"
	fi
}
function clear-buffer {
	buffer=()
	buffersyntax=()
	bufferexpand=()
	bufferdata=()
}

function toggle_hidden {
	((hidden==0)) && hidden=1 || hidden=0
	dired
}
function dired {
	((current_count++))
	set-buffer "dired_${current_count}"
	add-to-list
	declare -Ag "${current_buffer}_bufferdata"
	bufferdata=(
		[line]=1
		[base]=1
		[column]=0
		[info]='File picker'
		[mode]='dired'
		[help_message]='Pick a file'
		[filetype]='i*dired'
		[file]='*dired*'
		[modified]=0
		[menuline]='diredmenu'
	)
	size-full
	mapfile -t -O 1 buffer <<< "$(pickls)"
	make-render
	if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
		bufferdata+=(
			[line]=1
			[info]="$PWD"
		)
	else
		bufferdata[info]="error: empty"
	fi
	redraw
}
function dired-select {
	local line="${buffer[bufferdata[line]]}"
	if [ -d "$line" ]; then
		cd "$line"
		dired
	else
		read-buffer "$line" || exit 1
		redraw
	fi
}
function pickls {
	((hidden==0)) && printf '..\n' || printf '%s\n' .*
	printf '%s\n' *
}

function buffer-dialog {
	save openfile
	((current_count++))
	set-buffer "$1_${current_count}"
	add-to-list
	declare -Ag "${current_buffer}_bufferdata"
	copy-array overlay bckover
	overlay=()
	bufferdata=(
		[line]=1
		[base]=1
		[column]=0
		[info]="$2"
		[mode]=view
		[help_message]="$3"
		[filetype]='i*view'
		[file]="$4"
		[modified]=0
		[raw]=1
		[menuline]="menuline_$1"
	)
	size-full
	declare -Ag "menuline_$1"
	local -n menuline="${bufferdata[menuline]}"
	menuline=(
		[quit]='quit-view'
	)
}
function buffer-dialog-draw {
	copy-array buffer bufferexpand
	clear-screen
	redraw
}
function about {
	buffer-dialog about 'About Ebashs' 'About' '*about*'
	mapfile -t -O 1 buffer <<EOF
Ebashs $version
Copyrightn't () 2023 Aeknt. 

This is Ebashs, one component of the Bash/Bash operating system.

An editor written in pure bash via nonsense sphagetti code trying copying emacs.

Repo                     https://github.com/aeknt/spis
                         Ebashs comes with ABSOLUTELY NO WARRANTY




Based on                 https://github.com/comfies/bed

                                                                                
                                                                                
                               ..............                                   
                            @***%@@@@@@@@@@@@...                                
                     ** .*@@@@@@@@@@@@@@@@@@@@@..                               
                     .       @@&....,,#@@@@@@@@                                 
                      ....,@@@@@@@@@@@@@@@@@@                                   
                  /@@@@@@@@@@@@@@@@@@@@@@.                                      
                @@@@@@@,,...@@@&..                                              
              .@@@@@@@@@@@,,@@@&.                                               
              ..@@@@@@@@@@@@@@@&..                                              
                .../@@@@@@@@@@@@@@.....                                         
                   ....@@@@@@@@@@@@@@@&....                                     
                   ..(#@@@@@@@@@@@@@@@@@@@                                      
              ./@@@@@@@@@@@@@@@@%......                                         
          .@@@@@@@@@@@@@@@@.@@@&.                                               
        @@@@@@@@@@@@@@..   .@@@&.                                               
       .@@@@@@@@@@@@.      .@@@&.                                               
      ..@@@@@@@@@@@@/.......@@@&.                                               
       ...,@@@@@@@@@@@@@@@@@@@@&.................                               
           ...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..                           
               ....../@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#                            
                        ..,,,,*##@@@@@@@@@@@@@@@.      .###################.    
                      @@@@@@@@@@@@@@@@@@@@..        @@@@@@@@@@@@@@@@@@@@@@      
                   /@@@@@@@/........              @@@@@@@@@@@@@@@@@@@@.         
                                                                                
                                                                                

  ‚îÄ[bsd0]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Permission to use, copy, modify, and/or distribute this software for any purpose
  with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
  TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

EOF
	buffer-dialog-draw
}
function list-faces-display {
	buffer-dialog faces 'faces' 'faces' '*list-faces-display*'
	buffer=('')
	for face in "${!faces[@]}"; do
		buffer+=(
			"$(
				printf '%*s%b%s%b' -40 "${face}" "${faces[$face]}" "abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ" "${faces[default]}"
			)"
		)
	done
	buffer-dialog-draw
}
function table-init {
	table_columns="$1"
	shift
	local -i i=0
	for col in "$@"; do
		local -n n="table_column_$i"
		n="$col"
		((i++))
	done
}
function table-char {
	if (( ${#@} == 11 )); then
		table_char=("$@")
	else
		table_char=(‚îÄ ‚îÇ ‚îå ‚î¨ ‚îê ‚îú ‚îº ‚î§ ‚îî ‚î¥ ‚îò)
	fi
}
function table-top {
	printf '%s' "${table_char[2]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[3]}"
		((i==table_columns-1)) && printf '%s' "${table_char[4]}"
	done
	printf '\n'
}
function table-divider {
	table-title-line "$@"
}
function table-title-line {
	printf '%s' "${table_char[5]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[6]}"
		((i==table_columns-1)) && printf '%s' "${table_char[7]}"
	done
	printf '\n'
}
function table-bottom {
	printf '%s' "${table_char[8]}"
	for ((i=0; i<table_columns; i++)); do
		local -n n="table_column_$i"
		for ((ii=1; ii-1<n; ii++)); do
			printf '%s' "${table_char[0]}"
		done
		((i==table_columns-1)) || printf '%s' "${table_char[9]}"
		((i==table_columns-1)) && printf '%s' "${table_char[10]}"
	done
	printf '\n'
}
function table-item {
	local -i i=0
	for item in "$@"; do
		local -n n="table_column_$i"
		printf '%s' "${table_char[1]}"
		printf '%s' "$item"
		printf '%*s' $(( n - ${#item} )) ''
		((i++))
	done
	printf '%s' "${table_char[1]}"
	printf '\n'
}
function table-title {
	local -i i=0
	for title in "$@"; do
		local -n n="table_column_$i"
		printf '%s' "${table_char[1]}"
		printf '%*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		printf '%s' "$title"
		if ((${#title}%2==0)) && ((n%2==1)); then
			printf '%*s' $(( ( n / 2 - ( ${#title} / 2 ) ) + 1 )) ''
		else
			printf '%*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
		fi
		((i++))
	done
	printf '%s' "${table_char[1]}"
	printf '\n'
}
function code-block {
	while read -r; do echo "$REPLY"; done
}
function print-stdin {
	while read -r; do echo "$REPLY"; done
}
function text {
	while read -r; do
		l=${#REPLY}
		for ((i=0; i<l; i+=(bufferdata[size_x]/3)*2)); do
			printf '%s%s\n' "$1" "${REPLY:i:(bufferdata[size_x]/3)*2}"
		done
	done
}
function title {
	printf '[ %s ]' "$@"
}
function code {
	printf '%s' "$@"
}
function header {
	arg=$*
	table-init 1 $(( ${#arg} * 2 ))
	table-char ‚ïê ‚ïë ‚ïî X ‚ïó X X X ‚ïö X ‚ïù
	print-stdin <<EOF2
                                     $(table-top)
                                     $(table-title "${1}")
                                     $(table-bottom)
EOF2
}
function manual {
	buffer-dialog manual 'Ebashs manual' 'Manual' '*manual*'
	get-manual
	buffer-dialog-draw
}
function get-manual {
	#DO NOT edit following lines, makedoc handles them automatically
	# MAKEDOC INSERT README START
mapfile -t -O 1 buffer <<EOF
$(text <<EOF2
This is Ebashs, one component of the Bash/Bash operating system.
‚Ä¶ or even better an attempt to clone GNU Emacs in bash.
EOF2
)

$(text '    '<<EOF2
Note that the readme, may be currently outdated as I am changing the core functioning of Ebashs.

Versions of Ebashs ending in WIP-x are and will be broken, you can check version via M-x about or by reading the second line of Ebashs script.
EOF2
)

$(header EBASHS)

$(title DESCRIPTION)

$(text <<EOF2
An attempt to clone GNU Emacs but in bash.
EOF2
)

$(title FEATURES)

$(text <<EOF2
syntax highlighting
custom keybindings
custom modes -- so you can implement the evil too
file picker
mouse support
EOF2
)

$(title CONFIG)

$(text <<EOF2
Ebashs is configured via variables defined at start, you can separate it into file and then source it.
EOF2
)

    $(title 'OPTIONS ARRAY')

$(table-init 3 19 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item mouse ' 0' 'enable mouse at launch')
    $(table-item todonote ' 1' "highlight 'TODO:' & 'NOTE:'")
    $(table-item menuline ' 1' 'display menuline')
    $(table-item tabchar "$(code '|   ')" 'what should tab display as')
    $(table-item file_prompt "'Path: '" 'file setting prompt')
    $(table-item cmd_prompt "'M-x '" 'command line prompt')
    $(table-item cancelhex "'18 0' (C-x)" 'keybinding to exit debug input menu')
    $(table-item default_mode ' edit' 'what mode should be set on launch')
    $(table-item help_message "'F10 to open menu'" 'top right help message')
    $(table-item dired_message "'Pick a file'" 'same as above but for dired buffer')
    $(table-bottom)
EOF2
)

    $(title 'KEYBINDING ARRAYS')

$(text '    ' <<EOF2
Keybinding arrays match with modes. The array has to be associative and nammed $(code 'keys_<mode>'). $(code 'keys_def') is reserved and used as reference for other arrays, it's also reversed compared to other keybinding arrays.
EOF2
)

$(text '     ' <<EOF2
Keybindings are defined via hexadecimal syntax suffixed with ' 0'. Function $(code '@kbd field') is equivalent to $(code '${keys_def[field]}') but nicer. Function kbd provides Emacsy keybinding syntax.
EOF2
)

$(text '    ' <<EOF2
There is also a optionable option array possible for all keybinding arrays. Currently only defined option is [else] which defines what should happen if no key is matched from the keybinding. These arrays have to be named $(code 'key_options_<mode>').
EOF2
)

    $(title MODES)

$(text '    ' <<EOF2
Modes determine used keybinding and other properties of buffer.
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DESCRIPTION)
    $(table-title-line)
    $(table-item edit "general editing mode")
    $(table-item dired "mode used in file picker")
    $(table-item view "read-only mode")
    $(table-item menu "mode of menus")
    $(table-item debuginput "for getting input codes (M-x input)")
    $(table-item prefix "for C-x prefix")
    $(table-item prefix_help "for C-h prefix")
    $(table-item quit "for quit confirmation")
    $(table-item list_buffers "used in buffer switcher")
    $(table-bottom)
EOF2
)

    $(title STYLE)

$(text '    ' <<EOF2
Style of stuff is defined as escape code. See extensions/gruvboxdark for example of custom theme.
EOF2
)

$(table-init 3 32 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item default ' \e[m' 'Default face')
    $(table-item TODO ' \e[0;97;45m' "Highlighting of 'TODO: '")
    $(table-item NOTE ' \e[0;97;100m' "Highlighting of 'NOTE: '")
    $(table-item menu ' \e[0;37;40' 'Menuline')
    $(table-item menu-enabled-face ' \e[0;37;40' 'Items of menuline')
    $(table-item selected ' \e[30;45m' 'Selected item')
    $(table-item link ' \e[94m' 'Redirects')
    $(table-item menu-selected-face ' \e[30;45m' 'Selected item of menu')
    $(table-item mode-line ' \e[40;97m' 'Bottom statusline')
    $(table-item line-number ' \e[0;90m' 'Line count')
    $(table-item line-number-empty ' \e[0;90m' 'Lines that do not exist')
    $(table-item line-number-current-line ' \e[0;91m' 'Currently selected line')
    $(table-item tab-face ' \e[0;90m' 'Tabs')
    $(table-item minibuffer-prompt ' \e[m' 'Bottom commandline')
    $(table-divider)
    $(table-item font-lock-variable-string-face ' \e[0;36;48m' 'Quoted variables')
    $(table-item font-lock-comment-face ' \e[3;37;48m' 'Comments')
    $(table-item font-lock-variable-name-face ' \e[0;96m' 'Variables')
    $(table-item font-lock-argument-face ' \e[0;93m' 'Options')
    $(table-item font-lock-flow-face ' \e[0;93m' 'Control flow')
    $(table-item font-lock-pipe-face ' \e[1;94m' 'Pipes')
    $(table-item font-lock-bracket-face ' \e[1;95m' 'Brackets')
    $(table-item font-lock-constant-face ' \e[0;92m' 'Constants')
    $(table-item font-lock-string-face ' \e[0;32m' 'Strings')
    $(table-item font-lock-assign-face ' \e[0;94;108m' 'Variable assignments')
    $(table-item font-lock-function-name-face ' \e[0;30;44m' 'Function definitions')
    $(table-item font-lock-declare-face ' \e[0;91m' 'Keywords')
    $(table-bottom)
EOF2
)
$(text '    ' <<EOF2
Ebashs also includes the ansi-color-* faces, see M-x list-faces-display for full list.
EOF2
)

    $(title SYNTAX)

$(text '    ' <<EOF2
Defines which syntax functions should be used for which file types.
EOF2
)

    $(title MENULINE)

$(text '    ' <<EOF2
Defines items in menuline, content of keys defines which functions should be ran on invocation.
EOF2
)

    $(title MENUS)

$(text '    ' <<EOF2
Each menu has to have helper function to set it up on request:
EOF2
)
$(code-block bash <<EOF2
        <menu>() { declare -ng menucon=<menu>; menu; }
EOF2
)
$(text '    ' <<EOF2
The contents of menu are defined by an associative  array.
EOF2
)

    $(title COMMANDS)

$(text '    ' <<EOF2
Defines commands that can be used in $(code 'M-x').
EOF2
)

$(title EXTENDING)

$(text <<EOF2
Some of useful variables and for extending Ebashs
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
$(table-top)
$(table-title NAME DESCRIPTION)
$(table-title-line)
$(table-item buffer 'File data')
$(table-item buffersyntax 'Multidimensional buffer for rendering')
$(table-item bufferexpand 'Special characters filtered out')
$(table-item bufferdata 'Options of current buffer')
$(table-item charmap 'Definitions for bufferexpand')
$(table-item mode 'Current mode')
$(table-item commands 'List of M-x commands')
$(table-bottom)
EOF2
)

$(title 'SYNTAX HIGHLIGHTING')

$(text <<EOF2
Ebashs handles highlighting via checking 'syntax' array which consists of $(code '[file type]=syntax-function')
EOF2
)

    $(title 'SYNTAX FUNCTIONS')

$(text '    ' <<EOF2
Here is sample bash syntax function included with Ebashs:
EOF2
)

$(code-block bash <<EOF2
    syntax+=(
        [bash]=syntax-bash
    )
    function syntax-bash {
        ((comment)) && set-face font-lock-comment-face && return
        case "${word}" in
             *'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
            '"$'*) set-face font-lock-variable-string-face;;
            '#'*) set-face font-lock-comment-face && comment=1;;
            '$'*) set-face font-lock-variable-name-face;;
            '-'*) set-face font-lock-argument-face;;
            *'()') set-face font-lock-function-name-face;;
            '||'|'&&'|';'|'&') set-face font-lock-flow-face;;
            '>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
            '('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
            'function') set-face font-lock-function-name;;
            *"'"*) set-face font-lock-constant-face;;
            *'"'*) set-face font-lock-string-face;;
            *'='*) set-face font-lock-assign-face;;
            'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|
                'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|
                'let'|'shopt'|'trap'|'set'|'eval'
                ) set-face font-lock-keyword-face;;
            *) set-face default;;
        esac
    }
EOF2
)

$(text '    ' <<EOF2
The comments are handled specially via comment variable which gets reseted at every newline.
EOF2
)

$(title EXAMPLES)

$(text <<EOF2
A simple function to jump to line 11 when $(code 'C-x M-e') is pressed:
EOF2
)

$(code-block bash <<EOF2
    keys_prefix+=( # prefix is the mode for C-x
        [1b 65 0]='jump-to-11' # '1b 65 0' is the M-e in hex.
                               # You can use the M-x input to convert to hex. format.
    )
    jump-to-11() {
        [[ -n "${buffer[11]}" ]] && line=11 # If line 11 exists, set current line to 11.
        [[ "${bufferdata[mode]}" = 'prefix' ]] && quit-prefix
                                    # Since the key stroke contains C-x as prefix,
                                    # quit-prefix is is required as otherwise
                                    # it would stay in 'prefix' mode.
        redraw # Redraw whole buffer.
    }
EOF2
)

$(text <<EOF2
A function to write $(code 'Hello world!') at current cursor position when $(code 'M-x hi') is typed
EOF2
)

$(code-block bash <<EOF2
    commands+=(
        [hi]='hello-world' # Add command 'hi' invoking 'hello-world' function:
    )
    hello-world() {
        insert-word 'Hello-world!' # The function 'insert-word' handles insertion
                                   # of stuff, so no redraw or other magic is needed.
    }
EOF2
)

$(text '    ' <<EOF2
Create a menu containing previous functions $(code 'jump-to-11') & $(code 'hello-world'):
EOF2
)

$(code-block bash <<EOF2
    example-menu-function() { declare -ng menucon='example_menu'; menu; }
    # A function with which the menu will be invoked.

    declare -A example_menu
    example_menu=(
        [Jump to 11  ]='jump-to-11'  # The names of items in menu should have
        [Hello world!]='hello-world' # same width to display correctly.
    )

    # Add the example_menu into default menuline
    menulineedit+=(
        [Example]='example-menu-function'
    )
EOF2
)

$(title ETC)

$(text <<EOF2
Logo and it's krita file is in etc/

This readme is generated from doc/README.bml via makedoc script.
EOF2
)

$(title CREDITS)

$(text '    ' <<EOF2
Based on https://github.com/comfies/bed
EOF2
)

$(text '    '<<EOF2
Early versions of Ebashs/Bano can be found at
https://github.com/aeknt/bashbox/blob/master/bin/nano
https://github.com/aeknt/bashbox/blob/master/bin/bano
EOF2
)
EOF
	# MAKEDOC INSERT README STOP
}
function quit-view {
	copy-array bckover overlay
	restore openfile
	redraw
}

function write-buffer {
    true >"${bufferdata[file]}" # Set the file to an empty text file
    for ln in "${buffer[@]}"; do # Write in the buffer to the file
        echo "$ln" >>"${bufferdata[file]}"
    done
    bufferdata[modified]=0
    message="Wrote ${#buffer[@]} lines to '$file'"
}

function newline {
	bufferdata[modified]=1
	save-state
	buffer=("" "${buffer[@]:1:${bufferdata[line]}-1}" "" "${buffer[@]:${bufferdata[line]}}")
	unset 'buffer[0]'
	buffer[bufferdata[line]]="${buffer[${bufferdata[line]}+1]:0:${bufferdata[column]}}"
	buffer[bufferdata[line]+1]="${buffer[${bufferdata[line]}+1]:${bufferdata[column]}:${#buffer[${bufferdata[line]}+1]}}"
	bufferdata[column]=0
	syntax-shift
	next-line
}

syntax-shift() {
	local -a tmp1
	local -a tmp2
	local extmp1
	local extmp2
	for ((l=bufferdata[line];l<${#buffer[@]}+1;l++)); do
		local -n linearray="${current_buffer}_syntax${l}"
		copy-array linearray tmp1
		copy-array tmp2 linearray
		copy-array tmp1 tmp2
		extmp1="${bufferexpand[l]}"
		bufferexpand[l]="$extmp2"
		extmp2="$extmp1"
	done
	buffersyntax[buffer_length]="${current_buffer}_syntax${bufferdata[length]}"
	unset tmp1 tmp2
	make-render-area $((bufferdata[line])) $((bufferdata[line]+2))
}

function delete-line {
	bufferdata[modified]=1
	buffer-delete-line "${bufferdata[line]}"
	((bufferdata[line] == 1)) || previous-line
	redraw
}
function buffer-delete-line {
	local -i l=$1
	save-state
	buffer=("" "${buffer[@]:1:l-1}" "${buffer[@]:l+1}")
	buffersyntax=("" "${buffersyntax[@]:1:${bufferdata[line]}-1}")
}

fragment getrlr <<'+'
	local -i rlr
	unset ta
	local ta
	ta=${bufferexpand[${bufferdata[line]}]:0:${bufferdata[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bufferdata[column] + ta / 4 - ta))
+

fragment predelete <<'+'
	((bufferdata[selection])) && {
		delete-selection
		return
	}
	((${#buffer[${bufferdata[line]}]} == 0 )) && {
		delete-line
		bufferdata[column]="${#buffer[${bufferdata[line]}]}"
		redraw
		return 0
	}
+

function backspace {
	save-state
	@ predelete
	@ getrlr
	((rlr==0)) && {
		buffer[bufferdata[line]-1]="${buffer[bufferdata[line]-1]}${buffer[bufferdata[line]]}"
		delete-line
		bufferdata[column]=${#bufferexpand[${bufferdata[line]}]}
		redraw
		return 0
	}
	buffer[${bufferdata[line]}]="${buffer[${bufferdata[line]}]:0:$(( rlr - 1 ))}${buffer[${bufferdata[line]}]:${rlr}}"
	backward-char #go back with cursor
	make-render-line # copy the buffer into buffersyntax and bufferexpand
	redraw #draw it
	bufferdata[modified]=1
} && @add backspace
function delete {
	save-state
	@ predelete
	@ getrlr
	((rlr==${#buffer[bufferdata[line]]})) && {
		buffer[bufferdata[line]]="${buffer[bufferdata[line]]}${buffer[bufferdata[line]+1]}"
		move-next-line
		delete-line
		bufferdata[column]=${#bufferexpand[${bufferdata[line]}]}
		redraw
		return 0
	}
	buffer[bufferdata[line]]="${buffer[bufferdata[line]]:0:rlr}${buffer[bufferdata[line]]:rlr+1:${#buffer[bufferdata[line]]}}"
	make-render-line # copy the buffer into buffersyntax and bufferexpand
	redraw #draw it
	bufferdata[modified]=1
} && @add delete

function delete-selection {
	_ sy bufferdata[selection_start_y]
	_ ey bufferdata[selection_end_y]
	_ sx bufferdata[selection_start_x]
	_ ex bufferdata[selection_end_x]
	((sy == ey)) && {
		((sx > ex)) && __ sx ex
		buffer[sy]="${buffer[sy]:0:sx}${buffer[sy]:ex}"
		bufferdata[column]=$sx
		make-render-area $sy $((sy+1))
	} || {
		((sy > ey)) && {
			__ sy ey
			__ sx ex
		}
		buffer[sy]="${buffer[sy]:0:sx}"
		buffer[ey]="${buffer[ey]:ex}"
		buffer=("" "${buffer[@]:1:sy}" "${buffer[@]:ey}")
		buffersyntax=("" "${buffersyntax[@]:1:sy-1}")
		buffer[sy+1]="${buffer[sy]}${buffer[sy+1]}"
		buffer=("" "${buffer[@]:1:sy-2}" "${buffer[@]:sy}")
		bufferdata[line]=$sy
		bufferdata[column]=$sx
	}
	bufferdata[selection]=0
	redraw
	_ # unset reference aliases
}

declare -A keys_quit
keys_quit=(
	[79 0]='save-quit'
	[6e 0]='die'
	[63 0]='quit-quit'
)
function save-quit { write-buffer; die; }
function quit-quit {
	bufferdata[mode]="$bckmode"
	message='Quit canceled'
	redraw
}
function quit {
	if ((bufferdata[modified])); then
		[ -z "$bckmode" ] && bckmode="${bufferdata[mode]}"
		bufferdata[mode]='quit'
		redraw-statusline
		printf '\e[%s;0H' $((bufferdata[size_y] + bufferdata[position_y]))
		printf '%s' 'Buffer modified, save before close? [Y/n/c]'
	else
		die
	fi
}
function die {
	((nocleanup)) && exit "${errno:-0}"
    echo -e "\e[?1000;1006;1015l" #disable mouse tracking
	clear-screen # TODO fix the buffer switching
	printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
	printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
	
    exit "${errno:-0}" # Assume that we are exiting without an error
}

fragment move <<'+'
	for ((i = 0; i < ${1:-1}; i++)); do
+
fragment end <<'+'
	done
+
fragment keepcolumn <<'+'
	[ -z "$bckrl" ] && bckrl="${bufferdata[column]}"	
	(( ${#bufferexpand[bufferdata[line]]} < bufferdata[column] )) && bufferdata[column]=${#bufferexpand[bufferdata[line]]}
	(( ${#bufferexpand[bufferdata[line]]} > bckrl )) && bufferdata[column]=${bckrl}
+

function move-previous-line {
	@ move
		((bufferdata[line] > 1)) && ((bufferdata[line]--)) # As long as we can keep going up, go up
		((bufferdata[line] < bufferdata[base] + 1)) && ((bufferdata[base]--)) && # Push back the top if we need to
			((bufferdata[base] <= 0)) && bufferdata[base]=1 # Don't push back if our base is at 1
		@ keepcolumn
	@ end
} && @add move-previous-line

function move-next-line {
	@ move
		((bufferdata[line] < ${#buffer[@]}+1)) && ((bufferdata[line]++)) # If we can go down, go down
		# Move window down if needed
		((bufferdata[line] > bufferdata[base] + bufferdata[size_y] - 3 - bottomlines)) && ((bufferdata[base]++))
	   @ keepcolumn
	@ end
} && @add move-next-line


template move <<<'function @var 1 { @var 2 @var 3 ; redraw; }'
	@: previous-line move-previous-line '$@'
	@: next-line move-next-line '$@'
	@: scroll-down move-previous-line '$((bufferdata[size_y] - 3))'
	@: scroll-up move-next-line '$((bufferdata[size_y] - 3))'

function move-beginning-of-line { bufferdata[column]=0; redraw; }
function move-end-of-line { bufferdata[column]="${#bufferexpand[${bufferdata[line]}]}"; redraw; }

fragment select <<'+'
    ((bufferdata[selection])) || {
		bufferdata[selection_start_y]="${bufferdata[line]}"
		bufferdata[selection_start_x]="${bufferdata[column]}"
		bufferdata[selection]=1
	}
+
template select <<<'function @var 1 { @ select; @var 2 ; } && @add @var 1'
	@: select-forward forward-char
	@: select-backward backward-char
	@: select-next next-line
	@: select-previous previous-line

fragment forwardcheck <<'+'
	((bufferdata[column] > ${#bufferexpand[${bufferdata[line]}]})) && {
		bufferdata[column]=0
		 next-line
	 }
+
fragment backwardcheck <<'+'
	((bufferdata[column] < 0)) && ((bufferdata[line]==1)) && {
		bufferdata[line]=1
		bufferdata[column]=0
	}
	((bufferdata[column] < 0)) && {
		bufferdata[column]="${#bufferexpand[${bufferdata[line]}-1]}"
		previous-line
	}
+

template char <<'+'
	function @var 1 {
		@ move
			case "${bufferexpand[${bufferdata[line]}]:${bufferdata[column]} @var 2 1:1}" in
				't') bufferdata[column]=$(( bufferdata[column] @var 2 ${#options[tabchar]}));;
				*) ((bufferdata[column] @var 3 ));;
			esac; @var 4 ; bckrl=
		@ end
		if ((bufferdata[selection])); then
			redraw
		else
			redraw-cursor
		fi
	} && @add @var 1
+
	@: forward-char + ++ '@ forwardcheck'
	@: backward-char - -- '@ backwardcheck'

fragment charbreak <<'+'
	case "${bufferexpand[bufferdata[line]]:${bufferdata[column]}:1}" in
		't'|'s') break;;
	esac
+

function forward-word {
	((bufferdata[column] == ${#bufferexpand[bufferdata[line]]})) && {
		next-line
		move-beginning-of-line
	}
	while :; do
		((bufferdata[column] < ${#bufferexpand[bufferdata[line]]})) && ((bufferdata[column]++)) || break
		@ charbreak
	done
	redraw
} && @add forward-word
function backward-word {
	((bufferdata[column] == 0)) && {
		previous-line
		move-end-of-line
	}
	while :; do
		((bufferdata[column] > 0)) && ((bufferdata[column]--)) || break
		@ charbreak
	done
	redraw
} && @add backward-word

function set-mark-command {
	if ((bufferdata[selection])); then
		log info 'selection disable'
		bufferdata[selection]=0
	else
		bufferdata[selection]=1
		bufferdata[selection_start_y]="${bufferdata[line]}"
		bufferdata[selection_start_x]="${bufferdata[column]}"
		log info 'selection enable'
	fi
}

function shell {
	clear-screen
	bash # NOTE: in theory an external command
	redraw
}

function execute {
    ((bufferdata[line] == 0)) && return # If the line is not possible, do nothing
    printf '\e[?25h\e[%sH' "$((bufferdata[line] + 2 - bufferdata[base]))" # Reset cursor position and enable cursor
    read -re -p "$(printf '%4s ' "$")" # Present editable line
    if [[ "$REPLY" != "${buffer[${bufferdata[line]}]}" ]]; then # If the line is changed, update and inform
        buffer[${bufferdata[line]}]="$($REPLY)"
        bufferdata[modified]=1
    fi
    make-render
    redraw
}


function dump-array {
	# dump-buffer <array> <file>
	:> "$2"
	local -n source="$1"
	for idx in "${source[@]}"; do
	    echo "${idx}" >> "$2"
	done
}
function diff-buffer-syntax {
	# remove outdated lines from buffersyntax to set them for resyntaxing
	local -n source="$1"
	local -n target="$2"
	for idx in "${!target[@]}"; do
		[ "${source[idx]}" = "${target[idx]}" ] || buffersyntax[idx]=
	done
}
function diff-buffer-copy {
	local -n source="$1"
	local -n check="$2"
	local -n target="$3"
	[ -z "${source[*]}" ] && return 1 # | indicate that there's no previous buffer state to check against 
	[ -z "${check[*]}"  ] && return 1 # | should indicate save-state() to just copy the whole buffer
	target=()
	for idx in "${!source[@]}"; do
		[ "${source[idx]}" = "${check[idx]}" ] || target[idx]="${source[idx]}"
		[ "${source[idx]}" = "${check[idx]}" ] && target[idx]=''
	done
}
function diff-buffer-merge {
	local -n source="$1"
	local -n target="$2"
	for idx in "${!source[@]}"; do
		[ -n "${source[idx]}" ] && target[idx]="${source[idx]}"
	done
}

function save-state {
	((bufferdata[current_state]++))
	declare -ga "${current_buffer}_buffer_state_${bufferdata[current_state]}"
	diff-buffer-copy\
		buffer\
		"${current_buffer}_buffer_state_$((bufferdata[current_state]-1))"\
		"${current_buffer}_buffer_state_${bufferdata[current_state]}" || {
			copy-array buffer "${current_buffer}_buffer_state_${bufferdata[current_state]}"
		}
}

function undo {
	((bufferdata[current_state]--))
	((bufferdata[current_state]<0)) && {
		bufferdata[current_state]=0
		bufferdata[modified]=0
	}
	diff-buffer-syntax buffer "${current_buffer}_buffer_state_${bufferdata[current_state]}"
	diff-buffer-merge "${current_buffer}_buffer_state_${bufferdata[current_state]}" buffer
	redraw
}

function toggle-mouse {
	(("${options[mouse]}"==1)) && {
		printf '\e[?1000;1006;1015l'
		options[mouse]=0
		message='Disabled options[mouse]'
		return
		}
	(("${options[mouse]}"==0)) && {
		printf '\e[?1000;1006;1015h'
		options[mouse]=1
		message='Enabled options[mouse]'
		return
	}
}
function menuclick {
	local -n menuline="${bufferdata[menuline]}"
	#determine which item should be triggered
	[ -z "$1" ] && menulinep=0 || menulinep=$1
	local cx="${bufferdata[position_x]}"
	for a in "${!menuline[@]}"; {
		la="${#a}"
		((menulinep>cx)) && ((menulinep<(cx + la + 1))) && ${menuline[$a]}
		cx=$(( cx + la + 1 ))
	}
}
function menudraw {
	printf '\e[?25l'
	printf '\e[%s;0H' $menulinepy
	local mi=0
	for action in "${!menucon[@]}"; do
		if ((mi == menuselection)); then
			printf "\e[%sC${faces[menu-selected-face]}%s${reset}\n" $menulinep "$action"  
		else
			printf "\e[%sC${faces[menu-enabled-face]}%s${reset}\n" $menulinep "$action"
		fi
		((mi++))
	done
}
template menumove <<'+'
	function @var 1 {
		((menuselection @var 2 @var 3 )) && ((menuselection @var 4 ))
		menudraw
	}
+
@: menuup '>' 0 '--'
@: menudown '<' '${#menucon[@]} -1' '++'

function menuselect {
	local mi=0
	for action in "${!menucon[@]}"; do
		((mi == menuselection)) && "${menucon[$action]}"
		((mi++))
	done
}
function menuleave {
	ismenu=0
	bufferdata[mode]="${modebackup}"
	overlay=()
	redraw
}
function menu {
	((ismenu == 0 )) && modebackup="${bufferdata[mode]}"
	ismenu=1
	declare -ig menuselection=0
	bufferdata[mode]='menu'
	overlay+=('menudraw')
	redraw
}

fragment targetoff <<'+'
	target_x_offset=1
 	target_y_offset=1
+

function tile-buffers {
	log info "tile redraw-set ${options[tile_mode]}"
	bck_current_buffer="$current_buffer"
	case "${options[tile_mode]}" in
		vertical)
			target_x=$(( COLUMNS / ${#listbuffers[@]} ))
			@ targetoff
			target_y=$((LINES - 1));;
		horizontal)
			target_y=$(( LINES / ${#listbuffers[@]} - 1 ))
			@ targetoff
			target_x=$COLUMNS;;
		single)
			target_y=$LINES
			@ targetoff
			target_x=$COLUMNS;;
	esac
	for b in "${listbuffers[@]}"; do
		set-buffer "$b"
		bufferdata[size_x]=$target_x
		bufferdata[position_x]=$target_x_offset
		bufferdata[size_y]=$target_y
		bufferdata[position_y]=$target_y_offset
		case "${options[tile_mode]}" in
			vertical)
				target_x_offset=$((target_x_offset + target_x));;
			horizontal)
				target_y_offset=$((target_y_offset + target_y));;
		esac
		redraw
		
	done
	set-buffer "$bck_current_buffer"
} && @add tile-buffers
function tile-vertical {
	options[tile_mode]='vertical'
	tile-buffers
}
function tile-horizontal {
	options[tile_mode]='horizontal'
	tile-buffers
}
function tile-single {
	options[tile_mode]='single'
	bufferdata[size_x]=$COLUMNS
	bufferdata[size_y]=$((LINES - 1))
	bufferdata[position_x]=1
	bufferdata[position_y]=1
	redraw
}
function delete-window {
	local -a copy
	local i=0
	local index
	for b in "${listbuffers[@]}"
	do
		[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
		[[ "$b" = "$current_buffer"  ]] && index="$i"
		((i++))
	done
	unset listbuffers
	copy-array copy listbuffers
	current_buffer="${listbuffers[index-1]}"
	tile-buffers
}

fragment printarg <<'+'
	"${bufferdata[position_x]}"\
	"$i"\
	"${faces[default]}"\
+

function redraw-buffer-raw {
	for ((i = bufferdata[base]; i - bufferdata[base] < max; i++)); do
		printf "${faces[line-number]}"
		((i == bufferdata[line])) && printf "${faces[line-number-current-line]}" # Highlight line line-number if selected
		((i > ${#buffer[@]})) && printf "\e[%sG${faces[line-number-empty]}\e[K%$((bufferdata[length]/2))s~\e[m\n" "${bufferdata[position_x]}"\
				|| {
				printf "\e[%sG\e[K%${bufferdata[length]}s %b%s\n"\
					   @ printarg\
					   "${buffer[i]:bufferdata[basecolumn]:bufferdata[size_x] - (bufferdata[length] + 1)}"
			}
	done
} && @add redraw-buffer-raw

function redraw-buffer {
	for ((i = bufferdata[base]; i - bufferdata[base] < max; i++)); do
		printf '%b' "${faces[line-number]}"
		((i == bufferdata[line])) && printf "${faces[line-number-current-line]}" # Highlight line line-number if selected
		((i > ${#buffer[@]})) && printf "\e[%sG${faces[line-number-empty]}\e[K%$((bufferdata[length]/2))s~\e[m\n" "${bufferdata[position_x]}"\
				|| {
				# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
				[ -z "${buffersyntax[bufferdata[base]+bufferdata[size_y]-(bottomlines+toplines)+2]}" ] && {
					bottomest=$((bufferdata[base]+bufferdata[size_y]-(bottomlines+toplines)+2))
					make-render-area $bottomest $((bottomest+options[render_chunk]))
				}
				[ -z "${buffersyntax[i]}" ] && {
					make-render-area $((base + i)) $((base + i + 1)) # idk why make-render-line doesnt work here
				}
				local -n linearray="${buffersyntax[i]}"
				
				# draw the selection area
				((bufferdata[selection])) && {
					((i == bufferdata[selection_start_y])) &&
						((bufferdata[selection_start_y] == bufferdata[selection_end_y])) && {
							((bufferdata[selection_start_x] <= bufferdata[selection_end_x])) && {
									local -n sx=bufferdata[selection_start_x]
									local -n ex=bufferdata[selection_end_x]
							} || {
								local -n sx=bufferdata[selection_end_x]
								local -n ex=bufferdata[selection_start_x]
							}
							printf "\e[%sG\e[K%${bufferdata[length]}s %b%s%b%s%b%s\n"\
								   @ printarg\
								   "${linearray[*]:bufferdata[basecolumn]:sx}"\
								   "\e[m${faces[region]}"\
								   "${buffer[i]:sx:ex-sx}"\
								   "\e[m"\
								   "${linearray[*]:ex:bufferdata[size_x]}" 
							continue
						}
					((i >= bufferdata[selection_start_y])) && ((i <= bufferdata[selection_end_y])) && {
						selection-draw selection_start selection_end
						continue
					}
					((i <= bufferdata[selection_start_y])) && ((i >= bufferdata[selection_end_y])) && {
						selection-draw selection_end selection_start
						continue
					}
				}

				# due to escape codes present in buffersyntax,
				# the buffersyntax has to be multidimensional nonsense for perfomance reasons
				printf "\e[%sG\e[K%${bufferdata[length]}s %b%s\n"\
					   @ printarg\
					   "${linearray[*]:bufferdata[basecolumn]:bufferdata[size_x] - (bufferdata[length] + 1)}"
			}
	done
} && @add redraw-buffer

function selection-draw {
	if ((i == bufferdata["${1}_y"])); then
		printf "\e[%sG\e[K%${bufferdata[length]}s %b%s%b%s\n"\
			   @ printarg\
			   "${linearray[*]:bufferdata[basecolumn]:bufferdata[${1}_x]}"\
			   "\e[m${faces[region]}"\
			   "${buffer[i]:bufferdata[${1}_x]:bufferdata[size_x] - (bufferdata[length] + 1)}"
	elif ((i == bufferdata["${2}_y"])); then
		printf "\e[%sG\e[K%${bufferdata[length]}s %b%b%s%b%s\n"\
			   @ printarg\
			   "${faces[region]}"\
			   "${buffer[i]:bufferdata[basecolumn]:bufferdata[${2}_x]}"\
			   "\e[m"\
			   "${linearray[*]:bufferdata[${2}_x]:bufferdata[size_x]}"
	else
		printf "\e[%sG\e[K%${bufferdata[length]}s %b%b%s\n"\
			   @ printarg
			   "${faces[region]}" "${buffer[i]:bufferdata[basecolumn]:bufferdata[size_x] - (bufferdata[length] + 1)}"
	fi
} && @add selection-draw

fragment drawml <<'+'
	(("${options[menuline]}"==1)) && {
		local -n menuline="${bufferdata[menuline]}"
		printf "\e[0m\e[%s;%sH${faces[menu]}\e[?25l%*s\r%s"\
			   "${bufferdata[position_y]}"\
			   "${bufferdata[position_x]}"\
			   "${bufferdata[size_x]}"\
			   "${bufferdata[help_message]}"
		printf '\e[%sG%s\e[0m\n' "${bufferdata[position_x]}" "${!menuline[*]}"
	} || printf "\e[%s;%sH" "${bufferdata[position_y]}" "${bufferdata[position_x]}"
+

function redraw {
	printf '\e[?25l'
	
	# get length of line-number of lines
	local ltmp="${#buffer[@]}"
	bufferdata[length]="${#ltmp}"
	unset ltmp
	
	# update selection ends to current cursor
	((bufferdata[selection]==1)) && {
		bufferdata[selection_end_y]="${bufferdata[line]}"
		bufferdata[selection_end_x]="${bufferdata[column]}"
	}
	# move the buffer horizontally if needed
	((bufferdata[column] +3 < bufferdata[size_x] - bufferdata[length] - 1)) &&
		bufferdata[basecolumn]=0
	((bufferdata[column] +3 > bufferdata[size_x] - bufferdata[length] - 1)) &&
		bufferdata[basecolumn]=$((bufferdata[column] - (bufferdata[size_x] + bufferdata[position_x] - bufferdata[length] - 1) +3))

	@ drawml

	bckIFS="$IFS"
	IFS=''
	
	# Iterate over shown lines
	local -i max=$((bufferdata[size_y] - (toplines + bottomlines) + 1))
	if ((bufferdata[raw])); then
		# The raw rendering is just dirty hack to get better perfomance in buffer which don't need fancy effects
		# Will be removed once normal rendering is fast enough (or rather if it'll ever be
		redraw-buffer-raw
	else
		redraw-buffer
	fi
	
	redraw-statusline
	redraw-commandline
	redraw-cursor
	
	IFS="$bckIFS"
	
	# Render all overlays
	for o in "${overlay[@]}"; do
		"${o}"
	done
} && @add redraw

function redraw-cursor {
	printf '\e[?25h\e[%s;%sH'\
		   $((bufferdata[line] + options[menuline] - bufferdata[base] + bufferdata[position_y]))\
		   $((bufferdata[column] - bufferdata[basecolumn] + bufferdata[length] + 1 + bufferdata[position_x]))
}
function redraw-statusline {
	printf "\e[%s;%sH\n\e[%sG${faces[mode-line]}%*s\e[%sG%s %s (%s,%s) (screen: %s)\e[m" \
	       $((bufferdata[size_y] - 2 + bufferdata[position_y]))\
		   $((bufferdata[size_x] + bufferdata[position_x]))\
		   "${bufferdata[position_x]}"\
		   $((bufferdata[size_x]))\
		   "${bufferdata[info]}"\
		   "${bufferdata[position_x]}" \
	       "${bufferdata[mode]}"\
		   "$(base-name "${bufferdata[file]}")[${bufferdata[filetype]}]"\
		   "${bufferdata[line]}"\
		   "${bufferdata[column]}"\
		   "$current_buffer"
}
function redraw-commandline {
	printf "\e[%s;%sH\n${faces[minibuffer-prompt]}%*s\r%s\e[m" \
		   $((LINES-1)) 1 $((COLUMNS)) ' ' "$message"
}

function insert-word {
	save-state
	@ getrlr
	buffer[bufferdata[line]]="${buffer[${bufferdata[line]}]:0:${rlr}}$1${buffer[${bufferdata[line]}]:${rlr}}"\
		  #add at cursor position - amount of tabs * tab size
	make-render-line
	forward-char "${#1}"
	bufferdata[selection]=0
	redraw
	bufferdata[modified]=1
} && @add insert-word

function input-make-hex {
	input_hex=()
	local -i i=0
	echo "$1" | {
		while read -rsn1; do
			input_hex[i]="$(printf "%x\n" "'${1:$i}")"
			((i++))
		done
	}
}
function input-key {
	input-make-hex "$1"
	handle-hex "$1"
}
function handle-hex {
	for str in "${!keys_global[@]}"; do
		[ "$str" = "${input_hex[*]}" ] && {
			"${keys_global[$str]}"
			return
		}
	done
	local -i x y mode_contains=0
	local -n modekeys="keys_${bufferdata[mode]}" key_options="key_options_${bufferdata[mode]}"
	((${#key_options[@]})) && {
		[ -n "${key_options[always]}" ] && "${key_options[always]}"
	}
	for str in "${!modekeys[@]}"; do
		[ "$str" = "${input_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	done
	((${#key_options[@]})) && {
		((mode_contains == 0)) && [ -n "${key_options[else]}" ] && "${key_options[else]}"
	}
	((mode_contains == 1)) && {
		return
	}
	[ "${bufferdata[mode]}" = 'edit' ] || return
	(("${options[mouse]}"==1)) && {
		#parse mouse stuff somewhatish weirdly
		[ "${input_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
		[ "${input_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
		[ "${input_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
		[ "${input_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
		((skipnext==1)) && skipnext=0 && return
		((skipnext==0)) && [ "${input_hex[*]:0:2}" = '1b 5b' ] && {
			mapfile -t -d '' inputarray <<< "${1}"
			inputarray[-1]="${inputarray[-1]%?}"
			[ -z "${inputarray[2]}" ] && skipnext=1
			mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
			inputarray[-1]="${inputarray[-1]%?}"	
			mousemode="${inputarray[0]}"
			x="${inputarray[1]}"
			y="${inputarray[2]::-1}"
			#limitations of movenment
			#TODO:
			[ $y = "${bufferdata[position_y]}" ] && menuclick $x && return #handle menuline
			((x < (bufferdata[length] + bufferdata[position_x] + 2))) && {
				if [ "$mousemode" = '[<0' ]; then
					bufferdata[line]=$(( bufferdata[base] + ( (y - bufferdata[position_y]) - toplines) ))
					redraw
				elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
					clear-screen
					echo 'Enter the index: '
					read -re line
					redraw
				fi
				return
			}
			bufferdata[line]=$(( bufferdata[base] + ( y - bufferdata[position_y] - 1) ))
			bufferdata[column]=$(( x - (bufferdata[position_x] + bufferdata[length] + 2) ))
			((bufferdata[line] > ${#bufferexpand[@]})) && bufferdata[line]=${#bufferexpand[@]}
			((bufferdata[column] > ${#bufferexpand[bufferdata[line]]})) && bufferdata[column]=${#bufferexpand[bufferdata[line]]}
			redraw
			return
		}
	}
	#[ "${input_hex[*]:0:3}" = '1b 5b 3c' ] && return
	[ "${input_hex[*]:0:1}" = '1b' ] && return # TODO: prevent escape codes without hacky blocking
	[ "${bufferdata[mode]}" = edit ] && {
		[[ $1 =~ [[:cntrl:]] ]] && return
		insert-word "$1"
		[ "$1" = '	' ] && printf '\e[%sC' $((${#options[tabchar]} - 1))
		bufferdata[modified]=1
	}
}
function init-log {
	log=1
	declare -Ag "log_bufferdata"
	declare -ng bufferlog="log_buffer"
	log_bufferdata=(
		[base]=1
		[column]=0
		[info]='LOG'
		[mode]='view'
		[help_message]='LOG'
		[filetype]='i*view'
		[file]='*log*'
		[modified]=0
		[raw]=1
		[menuline]='menulog'
	)
	menulog=(
		[quit]='quit-view'
	)
	bufferlog=(
		''
		"[ LOG START ] Ebashs version $version"
		'time function            level  message'
	)
	lasttime="$(current-time '%s')"
}
function view-log {
	((log)) || {
		message='Error: log is not initialised'
		return
	}
	save openfile
	set-buffer log
	size-full
	copy-array overlay bckover
	overlay=()
	copy-array buffer bufferexpand
	clear-screen
	redraw
	for ae in "${!bufferdata[@]}"; do
		printf '%s: %s\n' "$ae" "${bufferdata[$ae]}" >> d
	done
}
function current-time {
	printf "%($1)T\\n"
}
function log {
	((log)) || return
	local type="$1"
	shift
	tooktime="$(( $(current-time '%s') - lasttime ))"
	case "$type" in
		warn)
			bufferlog+=(
				"${tooktime}s $(printf '%-20s' "${FUNCNAME[1]}") [ WARN ] $@"
			);;
		info)
			bufferlog+=(
				"${tooktime}s $(printf '%-20s' "${FUNCNAME[1]}") [ INFO ] $@"
			);;
		error)
			bufferlog+=(
				"! ${tooktime}s [ ERROR ] $(printf '%-20s' "${FUNCNAME[1]}") $@"
			);;
		bash)
			(($1==1)) && return
			bufferlog+=(
			    "${tooktime}s $(printf '%-20s' "${FUNCNAME[1]}") [ BASH ]"
				"$(printf '%30s' ' ') code $1"
				"$(printf '%30s' ' ') line $2"
				"$(printf '%30s' ' ') cmd  $3"
			);;

		*)
			bufferlog+=(
				"$type => ${tooktime}s in ${FUNCNAME[1]}() $@"
			);;

	esac
	lasttime="$(current-time '%s')"
}
## debug
# +debug -- basically like set -x but reports stuff into log
function +log {
	((log)) || return
	((options[log_functions])) && log '*' "${FUNCNAME[1]}"
	trap 'log bash $? $LINENO ${BASH_COMMAND}' ERR
}
function +debug {
	((log)) || return
	trap 'log DEBUG "${BASH_COMMAND}"' DEBUG
}
function load-config {
	local config_file
	local f
	f=~/.config/ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc ;[ -f "$f" ] && config_file="$f"
	[ -z "$config_file" ] && return
	source "$config_file"
}
function init {
	load-default-config #loads default config
	load-config
	((options[log])) && init-log # set up log buffer (M-x log)
	menulinepy=0; menulinep=0 # menu positions
	case "${options[menuline]}" in
		1) toplines=1;;
		0) toplines=0;;
	esac
	bottomlines=2
	reset='\e[0;0m'
	function update-menuline-menu {
		declare -Ag menufancy
		for item in "${!menulineedit[@]}"; do
			menufancy+=(["$(printf '%-12s' "$item")"]="${menulineedit["$item"]}")
		done
		menufancy+=([Quit        ]=quit)
	}
	update-menuline-menu
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	printf '\e[?1049h'
	(("${options[mouse]}")) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
    if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
		log info "argument $1"
        if [ -d "$1" ]; then
			log info "[$1] is directory => dired"
			cd "$1" || exit
			dired # enter the file selector in specified folder
		else
			log info "[$1] is file => read-buffer"
			read-buffer "$1"
		fi
    else
		log info "no arg => dired"
		dired # enter the file selector
	fi
	main
}
function main {
	log info 'entering main loop...'
	redraw
	while :; do
		local -a k=()
		local -i i=1    
		if read -rsN1 k[0]; then # Check for ready input
			while read -rsN1 -t0.0001 k[$i]; do ((i++)); done # Multibyte hack
			input-key "$(printf '%s' "${k[@]}")" # Handle keypress event
		fi
	done
}

# check if all the syntaxtic sugar had been loaded properly
[ "$1" = "--debug-fn" ] && nocleanup=1 exit 0
init "$@"
