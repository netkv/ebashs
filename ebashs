#!/bin/bash
version="0.7.13"
log_buffer+=('' 'START')
## Ebashs
#		Emacs-like editor written in pure Bash
#		Had been tested properly only on Bash 5.2, and will propably be broken on 4.x versions and definitelly on 3 and older.

shopt -s lastpipe # For syntax highlighting
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize && (:) # Enable and then trigger a terminal size refresh

declare -r DEFIFS="$IFS"
declare -A highlight faces faces_raw options charmap alias descriptions
declare -A menulineedit diredmenu menulinedebug
declare -A menufancy
declare -A keys_def keys_global
declare -a k_hex buffers_l log_buffer extensions
declare -n buffer bf_s bf_e bf_d
declare -i menuloc_x menuloc_y toplines bottomlines hidden ismenu comment current_count _isdone
declare -n menucon
declare message reset readin

function load-default-config {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options ‚Üí define-options() ‚Üí ass. array options
	#				global-set ‚Üí global-set-key ‚Üí define-key global ‚Üí as. ar. keys_global
	#				add-mode ‚Üí local-set-key ‚Üí define-key <keys> ‚Üí a. a. keys_<keys>
	#					mode-options ‚Üí local-set-mode-option ‚Üí define-mode-option ‚Üí a. a. key_options_<keys>
	#				set-alias ‚Üí add-alias ‚Üí a. a. alias
	#				add-menu ‚Üí local-set-menu ‚Üí define-menu <menu> ‚Üí menu_<menu>_0 & menu_<menu>_1
	#				set-highlight ‚Üí add-highlight ‚Üí a. a. highlight
					  
	set-options
		:: mouse 0
		:: todonote 1
		:: menu-line 1
		:: mode-line 1
		:: command-line 1 # note that disabling this means that any message will instead be draw on top of buffer
		:: line-number-mode 1
		:: empty-line-char '~'
		:: tabchar '‚îÇ   '
		:: file-prompt 'Path: '
		:: command-prompt 'M-x '
		:: cancelhex '18 0'
		:: default_mode 'edit'
		:: keep-message 0
		:: help-message "Ebashs $version"
		:: dired-message 'Pick a file'
		:: render-chunk 8
		:: log 0
		:: log-functions 0
		:: tty-linuxfb 1 # enable truecolor support for framebuffer
		:: full-redraw 0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	global-set
		:: "$(kbd C-x)" 'prefix'
		:: "$(kbd M-x)" 'execute-extended-command'
		:: '[f10]' 'menu-top'
		:: "$(kbd C-g)" 'quit-prefix'
		:: '[up]' 'previous-line'
		:: '[down]' 'next-line'
		:: '[right]' 'forward-char'
		:: '[left]' 'backward-char'
		:: '[next]' 'scroll-down'
		:: '[prior]' 'scroll-up'
		:: "$(kbd C-a)" 'move-beginning-of-line'
		:: "$(kbd C-e)" 'move-end-of-line'
		:: "$(kbd C-p)" 'previous-line'
		:: "$(kbd C-n)" 'next-line'
		:: "$(kbd C-f)" 'forward-char'
		:: "$(kbd M-f)" 'forward-word'
		:: "$(kbd C-b)" 'backward-char'
		:: "$(kbd M-b)" 'backward-word'
		:: "$(kbd C-p)" 'scroll-down'
		:: "$(kbd C-v)" 'scroll-up'

	add-mode edit
		:: '1b 5b 31 3b 32 41 0' 'select-previous'
		:: '1b 5b 31 3b 32 42 0' 'select-next'
		:: '1b 5b 31 3b 32 43 0' 'select-forward'
		:: '1b 5b 31 3b 32 44 0' 'select-backward'
		:: '1b 20 0' 'set-mark-command' # in gnu emacs this is C-SPC but i cant get that to be detected in bash so M-SPC will suffice
		:: '20 0' 'insert-space'
		:: "$(kbd C-h)" 'prefix-help'
		:: 'RET' 'newline'
		:: "$(kbd C-l)" 'newline'
		:: "$(kbd C-t)" 'execute'
		:: "$(kbd C-d)" 'delete-line'
		:: 'DEL' 'backspace'
		:: '[deletechar]' 'delete'
		:: "$(kbd M-g)" 'menukey'
		:: '1b 5b 48 0' 'move-beginning-of-line'
		:: "$(kbd C-i)" 'indent-for-tab-command'
		:: '1b 5b 46 0' 'move-end-of-line'
		mode-options
			:: else 'insert'

	add-mode dired
		:: RET 'dired-select'
		:: "$(kbd h)" 'toggle_hidden'
	
	add-mode view
		:: RET 'quit-view'

	add-mode doc
		:: RET 'doc-select'
		:: "$(kbd C-c)" 'quit-doc'
	
	add-mode list_buffers
		:: RET 'quit-view'
		mode-options
			:: else 'quit-view'
	
	add-mode prefix
		:: "$(kbd C-c)" 'quit'
		:: "$(kbd C-s)" 'write_buffer'
		:: "$(kbd C-f)" 'find-file'
		:: "$(kbd C-b)" 'list-buffers'
		:: "$(kbd b)" 'switch-to-buffer'
		:: "$(kbd 0)" 'delete-buffer'
		:: "$(kbd u)" 'undo'
		mode-options
			:: always 'quit-prefix'
			:: disable-global 1
	
	add-mode prefix_help
		:: "$(kbd C-g)" 'quit-prefix'
		:: "$(kbd C-a)" 'about'
		:: "$(kbd r)" 'manual'
		:: "$(kbd f)" 'describe-function'
		:: "$(kbd C-f)" 'describe'
		mode-options
			:: disable-global 1

	add-mode menu
		:: '[up]' 'menuup'
		:: '[down]' 'menudown'
		:: 'RET' 'menuselect'
		mode-options
			:: else 'menuleave'
			:: disable-global 1
	
	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
default_faces=(
		reset '\e[m'
		default "$(:weight normal)"
		TODO "$(:background magenta)"
		NOTE "$(:background gray)"
		menu "$(:mode inverse)"
		menu-enabled-face "$(:background black)"
		selected "$(:foreground black :background magenta)"
		link "$(:foreground light-blue)"
		button '\e[4m\e[1m'
		menu-selected-face "$(:foreground black :background magenta)"
		mode-line "$(:mode inverse)"
		file-name "$(:weight bold)"
		line-number "$(:foreground gray)"
		line-number-empty "$(:foreground gray)"
		line-number-current-line "$(:foreground light-red)"
		tab-face "$(:foreground gray)"
		region "$(:weight bold :background gray)"
		minibuffer-prompt "$(:weight normal)"
		# ansi colors # currently just for reference
		ansi-color-black '\e[40m'
		ansi-color-blue '\e[44m'
		ansi-color-bold '\e[1m'
		ansi-color-bright-black '\e[100m'
		ansi-color-bright-blue '\e[104m'
		ansi-color-bright-blue '\e[106m'
		ansi-color-bright-blue '\e[102m'
		ansi-color-bright-blue '\e[105m'
		ansi-color-bright-blue '\e[101m'
		ansi-color-bright-blue '\e[107m'
		ansi-color-bright-blue '\e[103m'
		ansi-color-cyan '\e[46m'
		ansi-color-green '\e[42m'
		ansi-color-inverse '\e[7m'
		ansi-color-italic '\e[3m'
		ansi-color-magenta '\e[45m'
		ansi-color-red '\e[41m'
		ansi-color-underline '\e[4m'
		ansi-color-white '\e[47m'
		ansi-color-white '\e[43m'
		# syntax highlighting
		font-lock-variable-string-face "$(:foreground cyan)"
		font-lock-comment-face "$(:slant italic :weight dim)"
		font-lock-variable-name-face "$(:foreground light-cyan)"
		font-lock-argument-face "$(:foreground light-yellow)"
		font-lock-flow-face "$(:foreground ligth-yellow)"
		font-lock-pipe-face "$(:weight bold :foreground light-blue)"
		font-lock-bracket-face "$(:weight bold :foreground light-gray)"
		font-lock-constant-face "$(:foreground light-green)"
		font-lock-string-face "$(:foreground green)"
		font-lock-assign-face "$(:foreground light-blue)"
		font-lock-function-name-face "$(:weight bold :foreground light-cyan)"
		font-lock-keyword-face "$(:foreground light-red)"
		font-lock-declare-face "$(:foreground red)"
	)
	load-theme default_faces

	## Aliases
	#		List of aliases for M-x.
	set-alias
		:: set-buffer-file 'find-file'
		:: read-file 'read-buffer'
		:: write-file 'write-buffer'
		:: force-quit 'die'
		:: menul 'menu-top'
		:: menu-file 'menu-file'
		:: input 'inputcodes'
		:: log 'view-log'

	## Menus
	#		Defined via ordered pseudo-associative double-arrays
	#			All menu items calling 'menu-top' get applied the 'button' face
	#
	#		Menu top is the top menuline & f10 menu	
	#		Menu dired is the top menuline in dired buffers	
	add-menu top
		:: File menu-file
		:: Keys menu-key
		:: Help menu-help
		:: Debug menu-debug
		:: Redraw refresh

	add-menu file
		:: '        BACK        ' menu-top
		:: 'Quit        C-x C-c ' quit
		:: 'Visit file  C-x C-f ' find-file
		:: 'Execute         C-t ' execute
		:: 'Save        C-x C-s ' write-buffer
		:: 'Dired               ' dired
	add-menu help
		:: '        BACK        ' menu-top
		:: 'Keybinding          ' menu-key
		:: 'About               ' about

	add-menu key
	    :: '        BACK        ' menu-top
		:: 'Exit        C-x C-c ' quit
		:: 'New Line    C-l | ‚èé ' newline
		:: 'Set target      M-r ' find-file
		:: 'Visit file  C-x C-f ' read-buffer
		:: 'Save file   C-x C-s ' write-buffer
		:: 'Delete Line     C-d ' delete-line
		:: 'Prev Line       C-p ' previous-line
		:: 'Next Line       C-n ' next-line
		:: 'Prev Page       C-y ' scroll-down
		:: 'Next Page       C-v ' scroll-up
		:: 'Execute         C-t ' execute
		:: 'Shell           C-s ' shell
		:: 'Force exist     M-q ' die
    add-menu debug
		:: '   BACK   ' menu-top
		:: 'clear     ' clear-screen
		:: 'refresh   ' refresh
		:: 'backspace ' backspace
		:: 'right     ' forward-char
		:: 'left      ' backward-char
		:: 'inputcodes' inputcodes
		:: 'faces     ' list-faces-display

	set-highlight
		:: 'shell' bash ksh dash sh mksh zsh ash oksh i\*bash 'busybox sh'
		:: 'ebashs' ebashs
		:: 'config' conf
		:: 'dired' i\*dired
		:: 'unknown' unknown

	add-menu dired
		:: 'toggle hidden (h)' "toggle_hidden"

	add-menu dialog
		:: quit 'quit-view'
}

## syntaxy sugar sugary syntax

function ebashs-extensions {
	log_buffer+=('- LOADING BASH EXTENSIONS -')
	function @ifs { IFS="$DEFIFS"; }
	
	# Make bash not be bashy enough
	function @doc {
		mapfile -t "description_${desc_count}"
		descriptions["function_${1}_description"]="description_${desc_count}"
		((desc_count++))
	} && @doc doc <<-'+'
Adds description to a function
doc <function>
Description text is supplied from stdin, so mostly heredoc.
	+
	
	@doc load-default-config <<-'+'
Load default config included with Ebashs.
	+

	# reverse of defun :D
	function nufed {
		((_addfragment==1)) && {
			@add '='
			_addfragment=0
		}
		IFS=
		local -a fn
		local deffn="function $_function"$'\n'
		mapfile fn <<<"$(declare -f '=')"
		for ((i=1; i<${#fn[@]}; i++)) {
			deffn+="${fn[i]}"
		}
		eval "$deffn"
		_isdone=0
	    @ifs
		unset '='
	}
	
	
	@doc copy-function <<'+'
copies function \$1 to function \$2
advantage of copying instead of creating wrapper alias functions should be in theory performance(?)

Little test script:
    1() {
    	echo hi > /dev/null
    }
    echo 1
    time for e in {0..100000}; do
    	1
    done
    
    2() {
    	1
    }
    echo 2
    time for e in {0..100000}; do
    	2
    done
    
    3() {
    	2
    }
    echo 3
    time for e in {0..100000}; do
    	3
    done
    
    4() {
    	3
    }
    echo 4
    time for e in {0..100000}; do
    	4
    done

output:
    1
    
    real	0m1,636s
    user	0m1,081s
    sys	0m0,540s
    2
    
    real	0m1,986s
    user	0m1,453s
    sys	0m0,518s
    3
    
    real	0m2,380s
    user	0m1,873s
    sys	0m0,491s
    4
    
    real	0m2,768s
    user	0m2,154s
    sys	0m0,595s

It seems like there's small performace gain.
+
	function copy-function {
		local -a fn
		local deffn="function $2"$'\n'
		mapfile fn <<<"$(declare -f "$1")"
		for ((i=1; i<${#fn[@]}; i++)) {
			deffn+="${fn[i]}"
		}
		eval "$deffn"
	}

	function defun {
		if [ -z "$1" ]; then
			nufed
		else
			((desc_count++))
			log_buffer+=("    DEFUN: $1")
			((_isdone)) && nufed
			_addfragment="${_pass_addfragment}"
			descriptions["function_${1}_description"]="description_${desc_count}"
			_function="$1"
			_isdone=1
			_last_add=add-doc
		fi
	} && @doc defun <<+
Begins defining an function
Function definition should be like:

	defun something
		:: some-docs
		function = {
			...
		}
	defun something-else
		:: ...	
		function = ...
	defun this-nonsense
		...
	def.. ...
	nufed
+
	function ::
		case "$_last_add" in
			add-menu) local-set-menu "$@";;
			set-alias) add-alias "$@";;
			set-highlight) add-highlight "$@";;
			global-set) global-set-key "$@";;
			set-options) define-option "$@";;
			add-doc) add-doc "$@";;
			add-mode) local-set-key "$@";;
			mode-options) local-set-mode-option "$@"
		esac
		
	function add-doc {
		local -n cdoc="description_${desc_count}"
		cdoc+=("${_indent}$*")
	}
	function doc {
		((desc_count++))
		descriptions["function_${1}_description"]="description_${desc_count}"
		_function="$1"
		_last_add=add-doc
		_indent=''
		shift
		[ -n "$*" ] &&
			:: "$*"
	}
	copy-function doc @@

	@@ :+ Add documentation indent
	function :+ {
		_indent+="    "
		:: "$*"
	}
	@@ :- Remove documentation indent
	function :- {
		_indent="${_indent:0:${#_indent}-4}"
		:: "$*"
	}
	# hell

	@@ defun-fragment Same as defun but includes fragments for the function
	function defun-fragment {
		_pass_addfragment=1
		defun "$@"
	}
		
	# fragments act basically like macros but with cooler name
	# see redraw-buffer function for example usage
	@@ fragment Creates a function-insertable macro
	function fragment {
		log_buffer+=("        FRAGMENT: $1")
		declare -ag "_fragment_$1"
		mapfile "_fragment_$1"
	}
	
	@@ @add Adds fragment to a function
	function @add {
		local -a _add_fn
		local -a _add_nfn
		local -i _add_f
		local -i _add_hf
		local _add_nfnline
		mapfile _add_fn < <(declare -f -- "$1")
		IFS=' '
		for _add_l in "${!_add_fn[@]}"; do
			_add_f=0
			_add_hf=0
			_add_nfnline=
			for _add_w in ${_add_fn[_add_l]}; do
				if [ "$_add_w" = '@' ]; then
					_add_f=1
				elif ((_add_f)); then
					_add_f=0
					_add_hf=1
					local -n _add_fragment="_fragment_${_add_w//[^[:alnum:]]/}"
					for _add_l1 in "${!_add_fragment[@]}"; do
						_add_nfnline+=" ${_add_fragment[_add_l1]}"
					done
				else
					_add_nfnline+=" $_add_w"
				fi
			done
			((_add_hf)) || _add_nfn+="${_add_fn[_add_l]}"
			((_add_hf)) && _add_nfn+="$_add_nfnline"
		done
		eval "${_add_nfn[*]}"
	}
	
	# templates allow creating functions with code changes with minimal code
	# @def creates function from teplate
	# @def <template_name> <@var 1> <@var 2>...
	# @: creates function from last defined template
	# @: <@var 1> <@var 2>...
	
	@@ template Creates a function template
	:: Function template is turned into function with @def function
	function template {
		log_buffer+=("        TEMPLATE: $1")
		_last_template="$1"
		declare -g "_template_$1"
		local -n tpl="_template_$1"
		IFS=''
		while read -r -d $'\n' tpll; do
			tpl+="$tpll"
		done
		@ifs
	}
	
	@@ @def Defines a function template
	function @def {
		local -n _tpl="_template_$1"
		local _fn
		local -i _n=0
		shift
		for _w in $_tpl; do
			case "$_w" in
				'@var')
					_n=1;;
				*)
					((_n)) && {
						_n=0
						_fn+="${!_w} "
						continue
					}
					_fn+="$_w "
			esac
		done
		eval "$_fn"
	}
	
	@@ @: Calls @def with lastest defined template as argument
	function @: { @def "$_last_template" "$@"; }
	
	# unbashing bash one step at time ¬∞o¬∞
	
	@@ _ Variable refernce helper
	function _ {
		# this function is here to simplify stuff as writing overlong variables indexed by overloong variable index...
		# ...is quite tiring <3
		[ -z "$1" ] && {
			for n in "${refalias[@]}"; do
				unset "$n"
			done
			unset refalias
			return
		}
		declare -gn "$1"="$2"
		refalias+=("$1")
	}
	
	@@ __ Swap variable references
	function __ {
		# swap two references
		local -n _swap_1="$1"
		local _swap_copy_1="${!_swap_1}"
		local -n _swap_2="$2"
		local _swap_copy_2="${!_swap_2}"
		declare -gn "$1"="${_swap_copy_2}"
		declare -gn "$2"="${_swap_copy_1}"
	}
	
	@@ @fn Shorthand for one line functions
	function @fn {
		[ -z "$*" ] && exit 1 # error if empty
		local name="$1"
		shift
		eval "function $name { $@; }"
	}

	@@ copy-array
	:: A univeral function to copy both normal and associative arrays
	function copy-array {
		local -n source="$1"
		local -n target="$2"
		target=()
		for idx in "${!source[@]}"; do
			target[idx]="${source[idx]}"
		done
	}

	@@ append-array
	:: Append array \$1 to \$2  
	function append-array {
		local -n source="$1"
		local -n target="$2"
		for idx in "${!source[@]}"; do
			target+=("${source[idx]}")
		done
	}
	
	@@ setface Convert colors to escape codes
	:: '$1' can be either one of colors:
	:+     black
	::     red
	::     green
	::     yellow
	::     blue
	::     magenta
	::     cyan
	::     ligth-gray
	::     gray
	::     light-red
	::     light-green
	::     light-yellow
	::     light-blue
	::     light-magenta
	::     light-cyan
	::     white
	:- 'or hex. color (like "#bb2040")'
	:: 'or indexed 256 color with "c" as prefix (like c127)'
	:: 'for background color $mode has to be 48 and for foreground 38'
	::
	:: If \$TERM \(current "$TERM"\) is \'linux\' \& option tty-linuxfb is 1 try to use true color even for tty
	:: Instead of normal '\e[$mode;r;g;bm' is used '\e]P$~1mode$Hexcode\e[$~2modem'
	:+     '$mode 38 ‚Üí $~1mode 2 & $~2mode 32'
	::     '$mode 48 ‚Üí $~1mode 1 & $~2mode 41'
	:- Note that the linuxfb colors are very experimental and suffer from cursor implicitly overwriting them on movenment
	function setface {
		[ -z "$1" ] && return
		case "$1" in
			black)      [ "$mode" = '38' ] && printf '\\e[30m' || printf '\\e[40m';;
			red)        [ "$mode" = '38' ] && printf '\\e[31m' || printf '\\e[41m';;
			green)      [ "$mode" = '38' ] && printf '\\e[32m' || printf '\\e[42m';;
			yellow)     [ "$mode" = '38' ] && printf '\\e[33m' || printf '\\e[43m';;
			blue)       [ "$mode" = '38' ] && printf '\\e[34m' || printf '\\e[44m';;
			magenta)    [ "$mode" = '38' ] && printf '\\e[35m' || printf '\\e[45m';;
			cyan)       [ "$mode" = '38' ] && printf '\\e[36m' || printf '\\e[46m';;
			light-gray) [ "$mode" = '38' ] && printf '\\e[37m' || printf '\\e[47m';;

			gray)          [ "$mode" = '38' ] && printf '\\e[90m' || printf '\\e[100m';;
			light-red)     [ "$mode" = '38' ] && printf '\\e[91m' || printf '\\e[101m';;
			light-green)   [ "$mode" = '38' ] && printf '\\e[92m' || printf '\\e[102m';;
			light-yellow)  [ "$mode" = '38' ] && printf '\\e[93m' || printf '\\e[103m';;
			light-blue)    [ "$mode" = '38' ] && printf '\\e[94m' || printf '\\e[104m';;
			light-magenta) [ "$mode" = '38' ] && printf '\\e[95m' || printf '\\e[105m';;
			light-cyan)    [ "$mode" = '38' ] && printf '\\e[96m' || printf '\\e[106m';;
			white)         [ "$mode" = '38' ] && printf '\\e[97m' || printf '\\e[107m';;
			*) case "${1::1}" in
				   '#')
					   if [ "$TERM" = 'linux' ] && ((options[tty-linuxfb])); then # Hack for linux framebuffer tty
						   case "$mode" in
							   38) printf '\\e]P2%s\\e[32m' "${1:1:6}" ;;
							   48) printf '\\e]P1%s\\e[41m' "${1:1:6}"
						   esac
					   else
						   local r="${1:1:2}"
						   local g="${1:3:2}"
						   local b="${1:5:2}"
						   printf '\\e[%d;2;%d;%d;%dm' "${mode}" $((16#$r)) $((16#$g)) $((16#$b))
					   fi;;
				   'c')
					   printf '\\e[%d;5;%dm' "${mode}" "${1:1}"
			   esac
		esac
		shift
		[ -n "$1" ] && "$@";
	}

	@@ :foreground set foreground color
	:: see setface for more info
	function :foreground { mode=38; setface "$@"; }
	
	@@ :background set background color
	:: see setface for more info
	function :background { mode=48; setface "$@"; }

	@@ :mode Sets text mode:
	:: '	inverse - inverses background and foreground'
	function :mode {
		case "$1" in
			inverse) printf '\\e[7m';;
		esac
		shift
		[ -n "$1" ] && "$@";
	}
	
	@@ :weight Sets thickness of text:
	:+     bold
	::     dim
	::     normal
	function :weight {
		case "$1" in
			bold) printf '\\e[1m';;
			dim) printf '\\e[2m';;
			normal) printf '\\e[m'
		esac
		shift
		[ -n "$1" ] && "$@";
	}
	
	@@ :slant Sets slant of text:
	:+     italic
	::     normal
	function :slant {
		case "$1" in
			italic) printf '\\e[3m';;
			normal) printf '\\e[m'
		esac
		shift
		[ -n "$1" ] && "$@";
	}
	
	@@ kbd Converts Emacs like key notation into hex.
	function kbd {
		local -i i=0
		local out
		local in
		local -i ch=1
		# Surely there is better solution...
		case "$1" in
			C-a) printf '1 0' ;; C-b) printf '2 0' ;;
			C-c) printf '3 0' ;; C-d) printf '4 0' ;;
			C-e) printf '5 0' ;; C-f) printf '6 0' ;;
			C-g) printf '7 0' ;; C-h) printf '8 0' ;;
			C-i) printf '9 0' ;; C-j) printf 'a 0' ;;
			C-k) printf 'b 0' ;; C-l) printf 'c 0' ;;
			C-m) printf 'd 0' ;; C-n) printf 'e 0' ;;
			C-o) printf 'f 0' ;; C-p) printf '10 0';;
			C-q) printf '11 0';; C-r) printf '12 0';;
			C-s) printf '13 0';; C-t) printf '14 0';;
			C-u) printf '15 0';; C-v) printf '16 0';;
			C-w) printf '17 0';; C-x) printf '18 0';;
			C-y) printf '19 0';; C-z) printf '1a 0';;
			*)  ch=0
				case "${1:0:2}" in
					M-) in="${1:2:1}";;
					*) in="$1"
				esac
		esac
		((ch)) && return
		echo "$in" | {
			while read -rsn1; do
				out+="$(printf "%x\n" "'${in:$i}") "
				((i++))
			done
		}
		out=${out::-1}
		printf '%s' "${out}"
	}

	@@ define-key defines keybinding
	:+     '$1' can be either:
	::     '[function-key]'
	::     '[arrow-key]'
	::     '[prior | next]'
	::     'RET'
	::     'DEL'
	::     '[delechar]'
	::     'hex code ending with 0'
	function define-key {
		local -n keys="keys_$1"
		case "$2" in
			#function keys
			'[f1]') keys[1b 4f 50 0]="$3";;
			'[f2]') keys[1b 4f 51 0]="$3";;
			'[f3]') keys[1b 4f 52 0]="$3";;
			'[f4]') keys[1b 4f 53 0]="$3";;
			'[f5]')  keys[1b 5b 31 35 7e 0]="$3";;
			'[f6]')  keys[1b 5b 31 37 7e 0]="$3";;
			'[f7]')  keys[1b 5b 31 38 7e 0]="$3";;
			'[f8]')  keys[1b 5b 32 39 7e 0]="$3";;
			'[f9]')  keys[1b 5b 32 30 7e 0]="$3";;
			'[f10]') keys[1b 5b 32 31 7e 0]="$3";;
			'[f11]') keys[1b 5b 32 33 7e 0]="$3";;
			'[f12]') keys[1b 5b 32 34 7e 0]="$3";;
			#arrow keys
			'[left]')  keys[1b 5b 44 0]="$3";;
			'[up]')    keys[1b 5b 41 0]="$3";;
			'[right]') keys[1b 5b 43 0]="$3";;
			'[down]')  keys[1b 5b 42 0]="$3";;
			#pg up & down
			'[prior]') keys[1b 5b 36 7e 0]="$3";;
			'[next]')  keys[1b 5b 35 7e 0]="$3";;
			#return
			'RET') keys[a 0]="$3";;
			#backspace & delete
			'DEL') keys[7f 0]="$3";;
			'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
			*) keys["$2"]="$3"
		esac
	}

	@@ local-set-key
	:: Sets keybinding of lastly defined mode
	:: See define-key for details
	@fn local-set-key 'define-key "$_last_keys" "$@"'

	@@ global-set-key
	:: Sets keybinding of global mode
	:: See define-key for details
	@fn global-set-key 'define-key global "$@"'

	@@ define-mode-option
	:: Sets option of mode '$1'
	function define-mode-option {
		local -n ko="key_options_$1"
		ko["$2"]="$3"
	}

	@@ local-set-mode-option See define-mode-option
	@fn local-set-mode-option 'define-mode-option "$_last_keys" "$@"'

	@@ mode-options Brings mode-options of lastly defined mode into \"focus\"
	@fn mode-options '_last_add="mode-options"'

	
	@@ add-alias Adds alias '$1' of command '$2...' to M-x
	function add-alias {
		local name="$1"
		shift
		alias["$name"]="$@"
	}

	@@ set-alias Brings into \"focus\" alias setting
	@fn set-alias '_last_add=set-alias'

	@@ add-highlight Sets highlighting mode '$1' for file types '$2...'
	function add-highlight {
		local name="$1"
		shift
		for i in "$@"; {
			highlight["$i"]="$name"
		}
	}

	@@ set-alias Brings into \"focus\" highlight setting
	@fn set-highlight '_last_add=set-highlight'

	@@ clear-screen clears screen
	@fn clear-screen "printf '\033c'"

	@@ add-mode
	:: Adds keybing mode
	function add-mode {
		log_buffer+=("        ADD MODE $1")
		_last_keys="$1"
		_last_add='add-mode'
		declare -Ag "keys_$1"
		declare -Ag "key_options_$1"
	}

	@@ add-menu
	:: Adds menu
	function add-menu {
		# create new menu function & array
		log_buffer+=("        ADD MENU $1")
		eval "function menu-${1} { menu $1; }"
		declare -ag "menu_${1}_0"
		declare -ag "menu_${1}_1"
		_last_menu="$1"
		_last_add='add-menu'
	}

	@@ local-set-menu Sets \"focused\" menu item
	@fn local-set-menu 'define-menu "$_last_menu" "$1" "$2"'

	@@ global-set Brings into \"focus\" global mode
	@fn global-set '_last_add=global-set'

	@@ define-option Defines options[] buffer
	@fn define-option 'options["$1"]="$2"'

	@@ set-options Brings into \"focus\" options setting
	@fn set-options '_last_add=set-options'

	@@ define-menu
	:: Defines item in menu '$1' with name '$2' with command '$3'
	:: '    If command is "menu-top" face button is used.'
	function define-menu {
		local -n menu_0="menu_${1}_0"
		local -n menu_1="menu_${1}_1"
		local item_0
		case "$3" in
			'menu-top') item_0="$(printf '%b' "${faces[button]}")$2";;
			*) item_0="$2"
		esac
		menu_0+=("$item_0")
		menu_1+=("$3")
	}

	@@ load-theme Loads theme from array
	function load-theme {
		local -i t=0
		local k
		local -n theme="$1"
		for i in "${theme[@]}"; {
			((t==0)) && {
				k="$i"
				t=1
			} || {
				faces["$k"]="$i"
				faces_raw["$k"]="$(printf '%b' "$i")"
				t=0
			}
		}
		((t)) && errno=1 die
	}

	@@ extension Set properites of extension
	function extension {
		log_buffer+=("- LOADING EXTENSION $1 -")
		extensions+=("$1")
		declare -Ag "${1}_ext_d"
		declare -ng ext_d="${1}_ext_d"
	}
	@@ version: Set version of extension
	function version: {
		ext_d[version]="$1"
	}
		
	log_buffer+=('- LOADING BASH EXTENSIONS DONE -')
}
ebashs-extensions
## rest of this garbageware

@@ refresh Refreshes buffer
:: '    clears screen, reset syntax, redraws'
function refresh {
	clear-screen
	bf_s=''
	draw-raw
	message="reloaded..."
	redraw
}

@@ switch-mode
:: Change current mode of buffer into '$1'
function switch-mode {
	bckmode="${bf_d[mode]}"
	bf_d[mode]="$1"
	redraw-statusline
}
@fn prefix switch-mode prefix
	@doc prefix <<<'-> switch-mode prefix'
@fn prefix-help switch-mode prefix_help
	@doc prefix-help <<<'-> switch-mode prefix-help'

@@ quit-prefix
:: Restores previous mode '(‚Üí quits prefixes)'
function quit-prefix {
	bf_d[mode]="$bckmode"
	unset bckmode
	redraw-statusline
}

@@ read-command
:: Works like normal "'read'" but for bottom commanline
function read-command {
	printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
	printf '\e[?25h'
	read -re -p "$1" "$2" || return 1
}

@@ execute-extended-command
:: 'Handles M-x command prompt & execution'
function execute-extended-command {
	read-command "${options[command-prompt]}" readin || return 1
	for lcmd in "${!alias[@]}"; {
		[ "$readin" = "$lcmd" ] && {
			${alias[$lcmd]}
			return
		}
	}
	$readin			
	((noredraw)) && noredraw=0 || redraw
}

### TODO: make this make sense
@@ save Saves current buffer references data as '$1'
function save {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	savedcurrent_buffer="$current_buffer"
}

@@ restore Restores '$1' buffer references data to current
function restore {
	local name="$1"
	local -n savedcurrent_buffer="current_buffer${name}"
	set-buffer "${savedcurrent_buffer}"
}

@@ set-syntax
:: Picks syntax highlighting function for current filetype
function set-syntax
	if [ -n "${highlight[*]}" ] && bf_d[syntax]="syntax-${highlight[unknown]}"
	then
		for syntax_setting in "${!highlight[@]}"; {
			[ "$syntax_setting" = "${bf_d[filetype]}" ] && {
				bf_d[syntax]="syntax-${highlight[$syntax_setting]}"
			}
		}
	else
		log warn 'no highlight array... using unknown'
	fi

@@ make-render Creates syntax highlighting for currently visible lines
function make-render {
	((bf_d[raw])) ||
		make-render-area "${bf_d[base]}" $((bf_d[base] + bf_d[size-y] + bf_d[loc-y]))
}

fragment setrender <<'+'
	line="$1"
	((bf_d[raw])) && return
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
+

defun-fragment make-render-area
	:: Creates syntax highlighting for lines from '$1' to '$2'
	function = {
		@ setrender
		for ((l=syntaxline;l<${2};l++)); do
			((l > $2)) && break
			local -n linearray="${current_buffer}_syntax${syntaxline}"
			linearray=()
			bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
			((syntaxline++))
			line="$l"
			make-render-line-loop
		done
		IFS="$bckeIFS"
	}
defun-fragment make-render-line
	:: Syntax highlights single line '$1'
	:: Defaults to currently selected line if no argument is passed
	function = {
		((${#1})) || local -i line=${bf_d[line]} ||
			@ setrender
		make-render-line-loop
		IFS="$bckeIFS"
	}

defun expand-char
	:: Creates bf_e for handling cursor movenment
	:: Is controled via charmap associative array
	:: "    Tab is 't'"
	:: "    Space is 's'"
	:: "    Any unmaped char is '0'"
	function = {
		IFS=
		while read -rsn1 char
		do
			[ -z "$char" ] && echo && continue
			case "${char}" in
				'	')
					local -i i
					for ((i = ${#options[tabchar]}; i > 0 ; i--)); do
						printf '%s' "${charmap[	]}"
					done;;
				' ') printf '%s' "${charmap[ ]}";;
				*)
					printf '0';;
			esac
		done
		@ifs
	}

defun make-render-line-loop
	:: Backend for make-render-area \& make-render-line
	function = {
		bf_e[line]="$(expand-char <<< "${buffer[line]}")"
		comment=0
		local word=''
		while read -rsn1 char
		do
			case "$char" in
				' ')
					syntax-word
					word=''
					face default ' ';;
				'	')
					syntax-word
					word=''
					face tab-face "${options[tabchar]}";;
				'')
					syntax-word
					word=''
					face default ' '
					return;;
				*) word+="${char}";;
			esac
		done  <<< "${buffer[line]}"
	}

defun syntax-word
	:: Decides what a word should highlighted as:
	:: '    If todonote option is enabled, highlight "NOTE:" & "TODO:"'
	:: '    If the word is supposed to be comment highlight it as it'
	:: '    Else pass it to current syntax function'
	function = {
		(("${options[todonote]}"==1)) && {
			case "$word" in
				'NOTE:') face NOTE "${word}"; return ;;
				'TODO:') face TODO "${word}"; return ;;
			esac
		}
		((comment)) && set-face font-lock-comment-face ||
				"${bf_d[syntax]}"
		face "$syntax_face" "$word"
	}

defun face
	:: Add highlighted word to multidimensional nonsense "'bf_s'" arry
	function = {
		IFS=' '
		[[ "$2" =~ ${2//?/(.)} ]]
	    linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
		IFS=''
	}
	
@fn set-face 'syntax_face="$1"'

defun syntax-shell
	:: Syntax function for shell
	:: Used faces:
	:: '    * font-lock-declare-face'
	:: '    * font-lock-variable-string-face'
	:: '    * font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '    * font-lock-variable-name-face'
	:: '    * font-lock-argument-face'
	:: '    * font-lock-function-name-face'
	:: '    * font-lock-flow-face'
	:: '    * font-lock-pipe-face'
	:: '    * font-lock-bracket-face'
	:: '    * font-lock-constant-face'
	:: '    * font-lock-string-face'
	:: '    * font-lock-assign-face'
	:: '    * font-lock-keyword-face'
	:: '    * font-lock-default-face'
	function =
		case "${word}" in
			*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
			'"$'*) set-face font-lock-variable-string-face;;
			'#'*) set-face font-lock-comment-face && comment=1;;
			'$'*) set-face font-lock-variable-name-face;;
			'-'*) set-face font-lock-argument-face;;
			*'()') set-face font-lock-function-name-face;;
			'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
			'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
			'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
			'function') set-face font-lock-function-name-face;;
			*"'"*) set-face font-lock-constant-face;;
			*'"'*) set-face font-lock-string-face;;
			*'='*) set-face font-lock-assign-face;;
			'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
				'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
				'let'|'shopt'|'trap'|'set'|'eval'\
					) set-face font-lock-keyword-face;;
			*) set-face default;;
		esac

defun syntax-ebashs
	:: Syntax function for Ebashs files cuz it\'s too weird already
	:: Used faces:
	:: '    * font-lock-declare-face'
	:: '    * font-lock-variable-string-face'
	:: '    * font-lock-comment-face & sets comment to 1 for syntax-word function'
	:: '    * font-lock-variable-name-face'
	:: '    * font-lock-argument-face'
	:: '    * font-lock-function-name-face'
	:: '    * font-lock-flow-face'
	:: '    * font-lock-pipe-face'
	:: '    * font-lock-bracket-face'
	:: '    * font-lock-constant-face'
	:: '    * font-lock-string-face'
	:: '    * font-lock-assign-face'
	:: '    * font-lock-keyword-face'
	:: '    * font-lock-default-face'
	function =
		case "${word}" in
			*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
			'"$'*) set-face font-lock-variable-string-face;;
			'#'*) set-face font-lock-comment-face && comment=1;;
			'$'*|'@') set-face font-lock-variable-name-face;;
			'-'*|'::') set-face font-lock-argument-face;;
			*'()') set-face font-lock-function-name-face;;
			'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
			'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
			'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
			'new'|'template'|'@def'|'@fn'|'@:') set-face font-lock-function-name-face;;
			*"'"*) set-face font-lock-constant-face;;
			*'"'*) set-face font-lock-string-face;;
			*'='*|'function') set-face font-lock-assign-face;;
			'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\
				'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\
				'let'|'shopt'|'trap'|'set'|'eval'\
					) set-face font-lock-keyword-face;;
			'set-options'|'global-set'|'define-key'|'local-set-key'|'add-mode'|'mode-options'|\
			 	'load-theme'|'set-alias'|'add-menu'|'@ifs'|'doc'|'_'|'__'|'copy-array'|\
				':foreground'|':background'|':mode'|'weight'|':slant'|'kbd'|'add-highlight'\
					) set-face font-lock-keyword-face;;
			*) set-face default;;
	esac
									 
@fn syntax-unknown 'set-face default'
	@doc syntax-unknown <<-'+'
Default syntax function
Sets everything to default face
	+

defun syntax-dired
	:: Highlighting for dired buffers
	:: '    * Directories ‚Üí link'
	:: '    * Files ‚Üí default'
	function = {
		[ -d "$word" ] && set-face link
		[ -f "$word" ] && set-face default
	}

defun syntax-config
	:: Basic syntax function for config files
	:: Used faces:
	:: '    * default'
	:: '    * font-lock-comment-face & sets comment to 1 for syntax-word function'	
	function =
		case "${word}" in
			'#'*) set-face font-lock-comment-face && comment=1;;
			*) set-face default;;
		esac

defun base-name
	:: Basically equivalent to the "'basename'" coreutil		
	function =
		for file in "$@"; {
			file="${file%/}"
			printf '%s\n' "${file##*/}"
		}

defun filetype
	:: Detect type of file '$1':					
	:: "    * If file doesn't exist ‚Üí unknown"
	:: "    * If is COMMIT_EDITMSG ‚Üí conf"
	:: "    * If is ebashs ‚Üí ebashs"
	:: "    * Extension ‚Üí"
	:: "    * Shebang ‚Üí"
	:: "    * Special shebang #@ ‚Üí"
	:: "    * unknown ‚Üí"
	function = {
		[ ! -f "$1" ] && {
			echo unknown
			return
		}
		#very ugly, TODO: redo this
		local filename shebang extension
		local -a filenamesplit shebangsplit
		[ $# = 0 ] && return
		[ "${1:0:1}" = '.' ] || {
			IFS='.'
			filename="${1%/}"
			filename="${filename##*/}"
			[ "$filename" = 'COMMIT_EDITMSG' ] && echo conf && return
			[ "$filename" = 'ebashs' ] && echo ebashs && return
			filenamesplit=($filename)
			extension="${filenamesplit[-1]}"
			[ "${#filenamesplit[@]}" -gt 1 ] && echo "$extension" && return
		}
		mapfile -n 1 file_data < "$1"
		shebang="$(echo -n "${file_data[@]}")"
		case "${shebang:0:2}" in
			'#!')
				shebang="${shebang%/}"
				IFS=' '
				shebangsplit=("${shebang##*/}")
				local shebangss=(${shebangsplit[-1]})
				case "${shebangss[0]}" in
					env)
						printf '%s\n' "${shebangss[1]}";;
					*)
						printf '%s\n' "${shebangsplit[-1]}";;
				esac
				;;
			'! ')
				mapfile -d ' ' -t split <<< "${shebang}"
				printf '%s\n' "${split[1]}"
				;;
			'##')
				mapfile -d ' ' -t split <<< "${shebang}"
				printf '%s\n' "${split[1]}"
				;;
			*) echo unknown
		esac
		@ifs
	}

defun find-file
	:: Asks for file and opens it
	function = {
		printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
		printf '\e[?25h'
		bind 'set disable-completion off' 2>/dev/null # Enable completion
		read -re -p "${options[file-prompt]}" command && {
			read-buffer "$command"
			[ -n "$bckmode" ] && bf_d[mode]="$bckmode" || bf_d[mode]=edit
			redraw
		}
		bind 'set disable-completion on' 2>/dev/null

	}


# draw something for nice transition
defun draw-raw
	:: Draw the buffer without any special effects
	:: Equivalent to setting bf_d[raw] to 1 in subshell
	function = (
		bf_d[raw]=1
		redraw
	)

defun size-full
	:: Sets size of buffer to be fullscreen
	function = {
		bf_d+=(
			[loc-x]=1
			[loc-y]=1
			[size-x]=$COLUMNS
			[size-y]=$((LINES - 1))
		)
	}

defun insert-debug-hex
	:: Adds hex code of keypress into buffer
	function = {
		buffer+=(
			"${k_hex[*]}"
		)
		next-line
		make-render-line
		redraw
}

defun set-buffer
	:: Switch to buffer \$1 
	function = {
		log info "switch to buffer [$1]"
		current_buffer="$1"
		declare -ng buffer="${current_buffer}_buffer"
		declare -ng bf_s="${current_buffer}_bf_s"
		declare -ng bf_e="${current_buffer}_bf_e"
		declare -ng bf_d="${current_buffer}_bf_d"
	}

defun switch-to-buffer
	:: Interactive wrapper for set-buffer
	function = {
		redraw
		read-command "Switch to buffer: " readin
		set-buffer "$readin"
		redraw
	}
defun add-to-list
	:: Adds a buffer into currently active buffer list
	function = {
		log info "added into buffer list: $current_buffer"
		buffers_l+=("$current_buffer")
	}
defun list-buffers
	:: Displays currently active buffers
	function = {
		save openfile
		set-buffer list_buffers
		declare -Ag "${current_buffer}_bf_d"
		bf_d=(
			[line]=1
			[base]=1
			[column]=0
			[modified]=0
			[mode]='list_buffers'
			[info]='Currently open buffers'
			[filetype]='i*buffer-list'
			[file]='*Buffer List*'
			[raw]=1
			[menuline]='about'
		)
		size-full
		add-menu about
		buffer=('')
		append-array buffers_l buffer
		redraw
	}
	
defun buffer-select
	:: Is ran on RET inside list_buffers buffer
	function = {
		set-buffer "${buffer[bf_d[line]]}"
		[ "${bf_d[mode]}" = 'prefix' ] && bf_d[mode]="$bckmode"
		redraw
	}


add-mode term
	local-set-key "$(kbd C-x)" 'quit-view'
	local-set-key 'RET' 'term-exec'
	local-set-key 'DEL' 'backspace'
	local-set-key '[deletechar]' 'delete'
	local-set-mode-option else 'insert'

defun term-exec
	:: Executes and displays command in term buffers
	function = {
		IFS=$'\n'
		local -i li=$((bf_d[line] + 1))
		while read -r comli; do
			buffer[li]="$comli"
			((li++))
		done <<< "$(${buffer[bf_d[line]]})"
		bf_d[line]=$li
		next-line
		make-render-line
		redraw
		@ifs
	}

defun term
	:: Opens a terminal buffer
	function = {
		save openfile
		((current_count++))
		set-buffer "term_${current_count}"
		add-to-list # add buffer to list of active buffers
		declare -Ag "${current_buffer}_bf_d"
		bf_d=(
			[line]=1
			[base]=1
			[column]=0
			[mode]='term'
			[info]='Terminal'
			[filetype]='i*bash'
			[file]='*term*'
			[modified]=0
			[raw]=0
			[menuline]='about'
		)
		set-syntax
		make-render
		size-full
		buffer=('')
		clear-screen
		redraw
	}

add-mode debuginput
	local-set-key "$(kbd C-x)" 'quit-view'
	local-set-mode-option else 'insert-debug-hex'
	local-set-mode-option disable-global 1

defun inputcodes
	:: Opens debug input buffer
	function = {
		save openfile
		((current_count++))
		set-buffer "bf_${current_count}"
		add-to-list # add buffer to list of active buffers
		declare -Ag "${current_buffer}_bf_d"
		bf_d=(
			[line]=1
			[base]=1
			[column]=0
			[mode]='debuginput'
			[info]='C-x (18 0) to close'
			[filetype]='i*term'
			[file]='*debuginput*'
			[modified]=0
			[raw]=1
			[menuline]='debuginput'
		)
		size-full
		buffer=(
			''
			'[ KEY DEBUGGER ]'
			''
			"Press any key to see Ebashs's native hex. representation of it."
			"See C-h f define-key & C-h f kbd for fancier key settings"
			''
		)
		bf_d[line]=7
		add-menu debuginput
		local-set-menu quit 'quit-debuginput'
		clear-screen
		redraw
	}

defun read-buffer
	:: Reads file \$1 into new buffer
	function = {
		log info "reading $* ..."
		((current_count++))
		set-buffer "bf_${current_count}"
		add-to-list
		declare -Ag "${current_buffer}_bf_d"
		bf_d=(
			[line]=0 # Currently selected line (0 means the buffer is empty)
			[base]=1 # Top-most line shown
			[column]=0 # Position of the cursor in $line
			[mode]="${options[default_mode]}"
			[info]="${options[help-message]}"
			[filetype]="$(filetype "$1")"
			[file]="$1"
			[menuline]='top'
			[current_state]=0
		)
		set-syntax # set bf_d[syntax]
		size-full
		[ -f "${bf_d[file]}" ] && mapfile -t -O 1 "${current_buffer}_buffer" <"${bf_d[file]}" # Read file into an array
		draw-raw

		# Ensure that something was actually read into the file
		[[ -n "${buffer[*]}" ]] && {
			message="Read ${#buffer[@]} lines from '${bf_d[file]}'"
		} || {
			message="'${bf_d[file]}' is empty"
		}
		bf_d[line]=1 # Indicate that we have a buffer loaded
		bf_d[modified]=0
	}

defun clear-buffer
	:: Empties buffer bf_s bf_e \& bf_d
	function = {
		buffer=()
		bf_s=()
		bf_e=()
		bf_d=()
	}

defun toggle_hidden
	:: Toggles hidden files in dired buffer
	function = {
		((hidden==0)) && hidden=1 || hidden=0
		dired
	}

defun dired
	:: Open file manager in current working directory
	function = {
		((current_count++))
		set-buffer "bf_${current_count}"
		add-to-list
		declare -Ag "${current_buffer}_bf_d"
		bf_d=(
			[line]=1
			[base]=1
			[column]=0
			[info]='Dired'
			[mode]='dired'
			[filetype]='i*dired'
			[file]='*dired*'
			[modified]=0
			[menuline]='dired'
		)
		set-syntax
		size-full
		mapfile -t -O 1 buffer <<< "$(list-directory)"
		make-render
		if [[ "${buffer[1]}" ]]; then # Ensure that something was actually read into the file
			bf_d+=(
				[line]=1
				[info]="$PWD"
			)
		else
			bf_d[info]="error: empty"
		fi
		redraw
	}
defun dired-select
	:: Select a item in dired buffer
		:: '    * If it is a directory cd into it and open new dired'
		:: '    * If it is a file open it via read-buffer function'
	function = if
		[ -d "${buffer[bf_d[line]]}" ]
	then
		cd "${buffer[bf_d[line]]}"
		dired
	else
		read-buffer "${buffer[bf_d[line]]}" || exit 1
		redraw
	fi

defun list-directory
	:: Basically like ls command
		:: '    If' \$hidden is 1 also show hidden files 
		:: '    If' \$hidden is 0 also show the special .. 
	function = {
		((hidden==0)) && printf '..\n' || printf '%s\n' .*
		printf '%s\n' *
	}

defun init-log
	:: Initializes M-x view-log buffer
	function = {
		log=1
		declare -Ag "log_bf_d"
		declare -ng bufferlog="log_buffer"
		log_bf_d=(
			[base]=1
			[column]=0
			[info]='LOG'
			[mode]='view'
			[help-message]='LOG'
			[filetype]='i*view'
			[file]='*log*'
			[modified]=0
			[raw]=1
			[menuline]='menulog'
		)
		add-menu
			:: 'quit' 'quit-view'

		bufferlog+=(
			''
			"Ebashs version $version"
			"    [ LOG START ]"
			''
			'System info:'
			"    Bash version: ${BASH_VERSION}"
			"    System: ${OSTYPE}"
			"    Terminal type: ${TERM}"
			"    Locale: ${LANG}"
			''
			'Loaded extensions:'
		)
		for e in "${extensions[@]}"; {
			local -n ext_d="${e}_ext_d"
			bufferlog+=("    $e - ${ext_d[version]}")
		}
		bufferlog+=(
			''
			'level time function message'
		)
		lasttime="$(current-time '%s')"
	}

defun view-log
	:: Opens log buffer
	function = {
		((log)) || {
			message='Error: log is not initialised'
			return
		}
		save openfile
		set-buffer log
		size-full
		copy-array buffer bf_e
		clear-screen
		redraw
		for ae in "${!bf_d[@]}"; do
			printf '%s: %s\n' "$ae" "${bf_d[$ae]}" >> d
		done
	}

defun current-time
	:: Basically like coreutil "'date'"
	function = {
	printf "%($1)T\\n"
	}

defun log
	:: Adds message into log
	:: '    info -- everything *should* be well'
	:: '    warn -- something is wrong but it *should* not break entire Ebashs'
	:: '    error -- something is wrong and anything can break, but it *can* still run(?)'
	:: '    fatal -- something is mega wrong and only thing left to do is to die'
	:: Is disabled when log wasn\'t initialised, see init-log for info
	function = {
		((log)) || return
		local type="$1"
		shift
		tooktime="$(( $(current-time '%s') - lasttime ))"
		bufferlog+=("[$type] ${tooktime}s [${FUNCNAME[1]}] $*")
		lasttime="$(current-time '%s')"
	}

defun log-echo
	:: Adds message into log without any special formating	
	function = {
		((log)) || return
		bufferlog+=("    $*")
	}

## debug
# +debug -- basically like set -x but reports stuff into log
defun +log	
	:: Debug function to add logging to function it\'s called from
	function = {
		((log)) || return
		((options[log-functions])) && log '*' "${FUNCNAME[1]}"
		trap 'log bash $? $LINENO ${BASH_COMMAND}' ERR
	}
defun +debug
	:: Debug function to add extensive \(set -x like\) logging to function it\'s called from
	function = {
		((log)) || return
		trap 'log DEBUG "${BASH_COMMAND}"' DEBUG
	}

defun buffer-dialog
	:: Helper functions for creating simple popup buffers
	function = {
		save openfile
		((current_count++))
		set-buffer "bf_${current_count}"
		add-to-list
		declare -Ag "${current_buffer}_bf_d"
		bf_d=(
			[line]=1
			[base]=1
			[column]=0
			[info]="$1"
			[mode]=view
			[filetype]='i*view'
			[file]="$2"
			[modified]=0
			[raw]=1
			[menuline]='dialog'
		)
		size-full
	}

defun buffer-dialog-draw
	:: Draws buffer created by buffer-dialog
	function = {
		copy-array buffer bf_e
		clear-screen
		redraw
	}

defun about
	:: Shows about information	
	function = {
		buffer-dialog 'About' '*about*'
		mapfile -t -O 1 buffer <<EOF
Ebashs $version
Copyrightn't(ƒç) 2022-2023 Aeknt. 
(bed: Copyrightn't(ƒç) 2020 Comfies.) 

This is Ebashs, one component of the Bash/Bash operating system.

An editor written in pure bash via nonsense sphagetti code trying copying emacs.

Repo                     https://github.com/aeknt/spis
                         Ebashs comes with ABSOLUTELY NO WARRANTY




Based on                 https://github.com/comfies/bed

                                                                                
                                                                                
                               ..............                                   
                            @***%@@@@@@@@@@@@...                                
                     ** .*@@@@@@@@@@@@@@@@@@@@@..                               
                     .       @@&....,,#@@@@@@@@                                 
                      ....,@@@@@@@@@@@@@@@@@@                                   
                  /@@@@@@@@@@@@@@@@@@@@@@.                                      
                @@@@@@@,,...@@@&..                                              
              .@@@@@@@@@@@,,@@@&.                                               
              ..@@@@@@@@@@@@@@@&..                                              
                .../@@@@@@@@@@@@@@.....                                         
                   ....@@@@@@@@@@@@@@@&....                                     
                   ..(#@@@@@@@@@@@@@@@@@@@                                      
              ./@@@@@@@@@@@@@@@@%......                                         
          .@@@@@@@@@@@@@@@@.@@@&.                                               
        @@@@@@@@@@@@@@..   .@@@&.                                               
       .@@@@@@@@@@@@.      .@@@&.                                               
      ..@@@@@@@@@@@@/.......@@@&.                                               
       ...,@@@@@@@@@@@@@@@@@@@@&.................                               
           ...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..                           
               ....../@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#                            
                        ..,,,,*##@@@@@@@@@@@@@@@.      .###################.    
                      @@@@@@@@@@@@@@@@@@@@..        @@@@@@@@@@@@@@@@@@@@@@      
                   /@@@@@@@/........              @@@@@@@@@@@@@@@@@@@@.         
                                                                                
                                                                                

  ‚îÄ[bsd0]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Permission to use, copy, modify, and/or distribute this software for any purpose
  with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
  TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
  DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

EOF
		buffer-dialog-draw
	}

defun list-faces-display
	:: Displays list of fases
	function = {
		buffer-dialog 'faces' '*list-faces-display*'
		buffer=('')
		for face in "${!faces[@]}"; do
			buffer+=(
				"$(
				printf '%*s%b%s%b' -40 "${face}" "${faces[$face]}" "abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ" "${faces[default]}"
			)"
			)
		done
		buffer-dialog-draw
	}

defun list-data-display
	:: Displays list of data of buffer from bf_d array	
	function = {
		read-command "List data of buffer: " readin
		local -n bdata="${readin}_bf_d"
		buffer-dialog faces 'data' '*list-data-display*'
		buffer=('')
		for datum in "${!bdata[@]}"; do
			buffer+=(
				"$(
				printf '%*s%s' -20 "${datum}" "${bdata[${datum}]}"
			)"
			)
		done
		buffer-dialog-draw
	}

defun list-options-display
	:: Displays list of options
	function = {
		buffer-dialog faces '*list-data-display*'
		buffer=('')
		for option in "${!options[@]}"; do
			buffer+=(
				"$(
					printf '%*s%s' -20 "${option}" "${options[${option}]}"
				)"	
			)
		done
		buffer-dialog-draw
	}

defun table-init
	:: Initializes bml \(bash markup language\) table
	function = {
		table_columns="$1"
		shift
		local -i i=0
		for col in "$@"; do
			local -n n="table_column_$i"
			n="$col"
			((i++))
		done
	}

defun table-char
	:: Sets style of bml table
	function =
		if (( ${#@} == 11 )); then
			table_char=("$@")
		else
			table_char=(‚îÄ ‚îÇ ‚îå ‚î¨ ‚îê ‚îú ‚îº ‚î§ ‚îî ‚î¥ ‚îò)
		fi

defun table-top
	:: Prints top line of bml table
	function = {
		printf '%s' "${table_char[2]}"
		for ((i=0; i<table_columns; i++)); do
			local -n n="table_column_$i"
			for ((ii=1; ii-1<n; ii++)); do
				printf '%s' "${table_char[0]}"
			done
			((i==table_columns-1)) || printf '%s' "${table_char[3]}"
			((i==table_columns-1)) && printf '%s' "${table_char[4]}"
		done
		printf '\n'
	}

defun table-title-line
	:: Prints bml table title divider
	function = {
		printf '%s' "${table_char[5]}"
		for ((i=0; i<table_columns; i++)); do
			local -n n="table_column_$i"
			for ((ii=1; ii-1<n; ii++)); do
				printf '%s' "${table_char[0]}"
			done
			((i==table_columns-1)) || printf '%s' "${table_char[6]}"
			((i==table_columns-1)) && printf '%s' "${table_char[7]}"
		done
		printf '\n'
	}
@fn table-divider 'table-title-line "$@"'

defun table-bottom
	:: Prints bottom line of bml table
	function = {
		printf '%s' "${table_char[8]}"
		for ((i=0; i<table_columns; i++)); do
			local -n n="table_column_$i"
			for ((ii=1; ii-1<n; ii++)); do
				printf '%s' "${table_char[0]}"
			done
			((i==table_columns-1)) || printf '%s' "${table_char[9]}"
			((i==table_columns-1)) && printf '%s' "${table_char[10]}"
		done
		printf '\n'
	}

defun table-item
	:: Prints line of table
	function = {
		local -i i=0
		for item in "$@"; do
			local -n n="table_column_$i"
			printf '%s' "${table_char[1]}"
			printf '%s' "$item"
			printf '%*s' $(( n - ${#item} )) ''
			((i++))
		done
		printf '%s' "${table_char[1]}"
		printf '\n'
	}

defun table-title
	:: Prints title of table
	function = {
		local -i i=0
		for title in "$@"; do
			local -n n="table_column_$i"
			printf '%s' "${table_char[1]}"
			printf '%*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
			printf '%s' "$title"
			if ((${#title}%2==0)) && ((n%2==1)); then
				printf '%*s' $(( ( n / 2 - ( ${#title} / 2 ) ) + 1 )) ''
			else
				printf '%*s' $(( n / 2 - ( ${#title} / 2 ) )) ''
			fi
			((i++))
		done
		printf '%s' "${table_char[1]}"
		printf '\n'
	}

defun code-block
	:: Prints code in bml document
	function = while read -r; do echo "$REPLY"; done

defun print-stdin
	:: Basically like coreutil "'cat'"
	function = while read -r; do echo "$REPLY"; done

defun text
	:: Prints normal text in bml document
	function =
		while read -r; do
			l=${#REPLY}
			for ((i=0; i<l; i+=(bf_d[size-x]/3)*2)); do
				printf '%s%s\n' "$1" "${REPLY:i:(bf_d[size-x]/3)*2}"
			done
		done

@fn title 'printf "[ %s ]" "$@"'
@fn code 'printf "%s" "$@"'

defun header
	:: Prints header of bml document
	function = {
		arg=$*
		table-init 1 $(( ${#arg} * 2 ))
		table-char ‚ïê ‚ïë ‚ïî X ‚ïó X X X ‚ïö X ‚ïù
		print-stdin <<-EOF2
                                     $(table-top)
                                     $(table-title "${1}")
                                     $(table-bottom)
		EOF2
	}

defun manual
	:: 'Displays C-h r manual buffer'
	function = {
		buffer-dialog 'Manual' '*manual*'
		get-manual
		buffer-dialog-draw
	}

defun get-manual
	:: Parses manual bml document
	function = {
	#DO NOT edit following lines, makedoc handles them automatically
	# MAKEDOC INSERT README START
mapfile -t -O 1 buffer <<EOF
$(text <<EOF2
This is Ebashs, one component of the Bash/Bash operating system.
‚Ä¶ or even better an attempt to clone GNU Emacs in bash.
EOF2
)

$(text '    '<<EOF2
Note that the readme, may be currently outdated as I am changing the core functioning of Ebashs.

Versions of Ebashs ending in WIP-x are and will be broken, you can check version via M-x about or by reading the second line of Ebashs script.
EOF2
)

$(text '    '<<EOF2
For more updated help run inside Ebashs $(code 'M-x describe') or $(code 'C-h C-f')
EOF2
)

$(header EBASHS)

$(title DESCRIPTION)

$(text <<EOF2
An attempt to clone GNU Emacs but in bash.
EOF2
)

$(title FEATURES)

$(text <<EOF2
syntax highlighting
custom keybindings
custom modes -- so you can implement the evil too
file picker
mouse support
EOF2
)

$(title CONFIG)

$(text <<EOF2
Ebashs is configured via variables defined at start, you can separate it into file and then source it.
EOF2
)

    $(title 'OPTIONS ARRAY')

$(table-init 3 19 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item mouse ' 0' 'enable mouse at launch')
    $(table-item todonote ' 1' "highlight 'TODO:' & 'NOTE:'")
    $(table-item menuline ' 1' 'display menuline')
    $(table-item tabchar "$(code '|   ')" 'what should tab display as')
    $(table-item file_prompt "'Path: '" 'file setting prompt')
    $(table-item cmd_prompt "'M-x '" 'command line prompt')
    $(table-item cancelhex "'18 0' (C-x)" 'keybinding to exit debug input menu')
    $(table-item default_mode ' edit' 'what mode should be set on launch')
    $(table-item help_message "'F10 to open menu'" 'top right help message')
    $(table-item dired_message "'Pick a file'" 'same as above but for dired buffer')
    $(table-bottom)
EOF2
)

    $(title 'KEYBINDING ARRAYS')

$(text '    ' <<EOF2
Keybinding arrays match with modes. The array has to be associative and nammed $(code 'keys_<mode>'). $(code 'keys_def') is reserved and used as reference for other arrays, it's also reversed compared to other keybinding arrays.
EOF2
)

$(text '     ' <<EOF2
Keybindings are defined via hexadecimal syntax suffixed with ' 0'. Function $(code '@kbd field') is equivalent to $(code '${keys_def[field]}') but nicer. Function kbd provides Emacsy keybinding syntax.
EOF2
)

$(text '    ' <<EOF2
There is also a optionable option array possible for all keybinding arrays. Currently only defined option is [else] which defines what should happen if no key is matched from the keybinding. These arrays have to be named $(code 'key_options_<mode>').
EOF2
)

    $(title MODES)

$(text '    ' <<EOF2
Modes determine used keybinding and other properties of buffer.
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DESCRIPTION)
    $(table-title-line)
    $(table-item edit "general editing mode")
    $(table-item dired "mode used in file picker")
    $(table-item view "read-only mode")
    $(table-item menu "mode of menus")
    $(table-item debuginput "for getting input codes (M-x input)")
    $(table-item prefix "for C-x prefix")
    $(table-item prefix_help "for C-h prefix")
    $(table-item quit "for quit confirmation")
    $(table-item list_buffers "used in buffer switcher")
    $(table-bottom)
EOF2
)

    $(title STYLE)

$(text '    ' <<EOF2
Style of stuff is defined as escape code. See extensions/gruvboxdark for example of custom theme.
EOF2
)

$(table-init 3 32 19 39; table-char
print-stdin <<EOF2
    $(table-top)
    $(table-title NAME DEFAULT DESCRIPTION)
    $(table-title-line)
    $(table-item default ' \e[m' 'Default face')
    $(table-item TODO ' \e[0;97;45m' "Highlighting of 'TODO: '")
    $(table-item NOTE ' \e[0;97;100m' "Highlighting of 'NOTE: '")
    $(table-item menu ' \e[0;37;40' 'Menuline')
    $(table-item menu-enabled-face ' \e[0;37;40' 'Items of menuline')
    $(table-item selected ' \e[30;45m' 'Selected item')
    $(table-item link ' \e[94m' 'Redirects')
    $(table-item menu-selected-face ' \e[30;45m' 'Selected item of menu')
    $(table-item mode-line ' \e[40;97m' 'Bottom statusline')
    $(table-item line-number ' \e[0;90m' 'Line count')
    $(table-item line-number-empty ' \e[0;90m' 'Lines that do not exist')
    $(table-item line-number-current-line ' \e[0;91m' 'Currently selected line')
    $(table-item tab-face ' \e[0;90m' 'Tabs')
    $(table-item minibuffer-prompt ' \e[m' 'Bottom commandline')
    $(table-divider)
    $(table-item font-lock-variable-string-face ' \e[0;36;48m' 'Quoted variables')
    $(table-item font-lock-comment-face ' \e[3;37;48m' 'Comments')
    $(table-item font-lock-variable-name-face ' \e[0;96m' 'Variables')
    $(table-item font-lock-argument-face ' \e[0;93m' 'Options')
    $(table-item font-lock-flow-face ' \e[0;93m' 'Control flow')
    $(table-item font-lock-pipe-face ' \e[1;94m' 'Pipes')
    $(table-item font-lock-bracket-face ' \e[1;95m' 'Brackets')
    $(table-item font-lock-constant-face ' \e[0;92m' 'Constants')
    $(table-item font-lock-string-face ' \e[0;32m' 'Strings')
    $(table-item font-lock-assign-face ' \e[0;94;108m' 'Variable assignments')
    $(table-item font-lock-function-name-face ' \e[0;30;44m' 'Function definitions')
    $(table-item font-lock-declare-face ' \e[0;91m' 'Keywords')
    $(table-bottom)
EOF2
)
$(text '    ' <<EOF2
Ebashs also includes the ansi-color-* faces, see M-x list-faces-display for full list.
EOF2
)

    $(title SYNTAX)

$(text '    ' <<EOF2
Defines which syntax functions should be used for which file types.
EOF2
)

    $(title MENULINE)

$(text '    ' <<EOF2
Defines items in menuline, content of keys defines which functions should be ran on invocation.
EOF2
)

    $(title MENUS)

$(text '    ' <<EOF2
Each menu has to have helper function to set it up on request:
EOF2
)
$(code-block bash <<EOF2
        <menu>() { declare -ng menucon=<menu>; menu; }
EOF2
)
$(text '    ' <<EOF2
The contents of menu are defined by an associative  array.
EOF2
)

    $(title ALIAS)

$(text '    ' <<EOF2
Defines aliases that can be used in $(code 'M-x').
EOF2
)
$(text '    ' <<EOF2
Use function $(code add-alias name command) to define.
EOF2
)

$(title EXTENDING)

$(text <<EOF2
Some of useful variables and for extending Ebashs
EOF2
)

$(table-init 2 19 43; table-char
print-stdin <<EOF2
$(table-top)
$(table-title NAME DESCRIPTION)
$(table-title-line)
$(table-item buffer 'File data')
$(table-item buffersyntax 'Multidimensional buffer for rendering')
$(table-item bufferexpand 'Special characters filtered out')
$(table-item bufferdata 'Options of current buffer')
$(table-item charmap 'Definitions for bufferexpand')
$(table-item mode 'Current mode')
$(table-item commands 'List of M-x commands')
$(table-bottom)
EOF2
)

$(title 'SYNTAX HIGHLIGHTING')

$(text <<EOF2
Ebashs handles highlighting via checking 'syntax' array which consists of $(code '[file type]=syntax-function')
EOF2
)

    $(title 'SYNTAX FUNCTIONS')

$(text '    ' <<EOF2
Here is sample bash syntax function included with Ebashs:
EOF2
)

$(code-block bash <<EOF2
    set-highlight
        :: shell bash ksh dash sh mksh zsh ash oksh i*bash

	defun syntax-shell
		:: Syntax function for shell
		:: Used faces:
		:: '    * font-lock-declare-face'
		:: '    * font-lock-variable-string-face'
		:: '    * font-lock-comment-face & sets comment to 1 for syntax-word function'
		:: '    * font-lock-variable-name-face'
		:: '    * font-lock-argument-face'
		:: '    * font-lock-function-name-face'
		:: '    * font-lock-flow-face'
		:: '    * font-lock-pipe-face'
		:: '    * font-lock-bracket-face'
		:: '    * font-lock-constant-face'
		:: '    * font-lock-string-face'
		:: '    * font-lock-assign-face'
		:: '    * font-lock-keyword-face'
		:: '    * font-lock-default-face'
		function =
			case "${word}" in
				*'=()'|'declare'|'local'|'typeset') set-face font-lock-declare-face;;
				'"$'*) set-face font-lock-variable-string-face;;
				'#'*) set-face font-lock-comment-face && comment=1;;
				'$'*) set-face font-lock-variable-name-face;;
				'-'*) set-face font-lock-argument-face;;
				*'()') set-face font-lock-function-name-face;;
				'||'|'&&'|';'|'&') set-face font-lock-flow-face;;
				'>'|'<'|'|'|'>>'|'<<'|'<<<') set-face font-lock-pipe-face;;
				'('|')'|'{'|'}'|'[['|']]'|'['|']') set-face font-lock-bracket-face;;
				'function') set-face font-lock-function-name-face;;
				*"'"*) set-face font-lock-constant-face;;
				*'"'*) set-face font-lock-string-face;;
				*'='*) set-face font-lock-assign-face;;
				'echo'|'return'|'case'|'esac'|'for'|'while'|'do'|'done'|'if'|'elif'|\\
					'else'|'printf'|'fi'|'continue'|'exit'|'bind'|'then'|'break'|'read'|\\
					'let'|'shopt'|'trap'|'set'|'eval'\\
						) set-face font-lock-keyword-face;;
				*) set-face default;;
			esac
EOF2
)

$(text '    ' <<EOF2
The comments are handled specially via comment variable which gets reseted at every newline.
EOF2
)

$(title EXAMPLES)

$(text <<EOF2
A simple function to jump to line 11 when $(code 'C-x M-e') is pressed:
EOF2
)

$(code-block bash <<EOF2
    keys_prefix+=( # prefix is the mode for C-x
        [1b 65 0]='jump-to-11' # '1b 65 0' is the M-e in hex.
                               # You can use the M-x input to convert to hex. format.
    )
    jump-to-11() {
        [[ -n "${buffer[11]}" ]] && line=11 # If line 11 exists, set current line to 11.
        [[ "${bufferdata[mode]}" = 'prefix' ]] && quit-prefix
                                    # Since the key stroke contains C-x as prefix,
                                    # quit-prefix is is required as otherwise
                                    # it would stay in 'prefix' mode.
        redraw # Redraw whole buffer.
    }
EOF2
)

$(text <<EOF2
A function to write $(code 'Hello world!') at current cursor position when $(code 'M-x hi') is typed
EOF2
)

$(code-block bash <<EOF2
    commands+=(
        [hi]='hello-world' # Add command 'hi' invoking 'hello-world' function:
    )
    hello-world() {
        insert-word 'Hello-world!' # The function 'insert-word' handles insertion
                                   # of stuff, so no redraw or other magic is needed.
    }
EOF2
)

$(text '    ' <<EOF2
Create a menu containing previous functions $(code 'jump-to-11') & $(code 'hello-world'):
EOF2
)

$(code-block bash <<EOF2
    example-menu-function() { declare -ng menucon='example_menu'; menu; }
    # A function with which the menu will be invoked.

    declare -A example_menu
    example_menu=(
        [Jump to 11  ]='jump-to-11'  # The names of items in menu should have
        [Hello world!]='hello-world' # same width to display correctly.
    )

    # Add the example_menu into default menuline
    menulineedit+=(
        [Example]='example-menu-function'
    )
EOF2
)

$(title ETC)

$(text <<EOF2
Logo and it's krita file is in etc/

This readme is generated from doc/README.bml via makedoc script.
EOF2
)

$(title CREDITS)

$(text '    ' <<EOF2
Based on https://github.com/comfies/bed
EOF2
)

$(text '    '<<EOF2
fff by Dylan Araps https://github.com/dylanaraps/fff as base for extensions/efff
Licensed under the MIT license see extensions/efff for details
EOF2
)

$(text '    '<<EOF2
Early versions of Ebashs/Bano can be found at
https://github.com/aeknt/bashbox/blob/master/bin/nano
https://github.com/aeknt/bashbox/blob/master/bin/bano
EOF2
)
EOF
	# MAKEDOC INSERT README STOP
	}

defun describe-function
	:: Displays help and info of function
	function = {
		redraw
		read-command 'Describe function: ' function || return 1
		buffer-dialog 'Describe' '*describe*'
		mapfile -t -O 1 buffer <<< "$(get-description "$function")"
		buffer-dialog-draw
	}

defun describe
	:: Displays help and info of all functions
	function = {
	    save openfiledoc
		((current_count++))
		set-buffer "bf_${current_count}"
		add-to-list
		declare -Ag "${current_buffer}_bf_d"
		bf_d=(
			[line]=1
			[base]=1
			[column]=0
			[info]="Documentation"
			[mode]=doc
			[filetype]='i*doc'
			[file]="Functions"
			[modified]=0
			[raw]=1
			[menuline]='dialog'
		)
		size-full
		local buffertmp=$'\n'
		while read -r fn;  do
			#buffertmp+="$(get-description "${fn:11}")"$'\n'
			buffertmp+="${fn:11}"$'\n'
		done <<< "$(declare -F)"
		mapfile -t buffer <<< "$buffertmp"
		buffer-dialog-draw
}

defun doc-select	
	:: Select documentation item
	function = {
		local function="${buffer[bf_d[line]]}"
	   	buffer-dialog 'Describe' '*describe*'
		mapfile -t -O 1 buffer <<< "$(get-description "$function")"
		buffer-dialog-draw
	}

defun quit-doc
	:: Quits and restores previous buffer.
	function = {
		restore openfiledoc
		redraw
	}
	
@fn is-function 'declare -F -- "$1" > /dev/null'
defun get-description
	:: Prints desciption of function \$1
	function = {
		is-function "$1" || {
			echo "$1 is not a Ebashs function"
			return
		}
		printf "[ $1 ]\n"
		[ -z "${descriptions[function_${1}_description]}" ] && {
			echo 'Function has no documentation'
			return
		}
		local -n fn_desc="${descriptions[function_${1}_description]}"
		((${#fn_desc[@]})) && {
			echo
			for l in "${fn_desc[@]}"; {
				printf "%s\n" "$l"
			}
			for i in {0..25}; {
				printf '\n'
			}
			printf '[ Source ]\n\n'
			declare -f "$1"
		}
	}

defun quit-view
	:: Quits and restores previous buffer.
	:: Used mainly for dialog buffers.
	function = {
		restore openfile
		redraw
	}

defun newline
	:: Inserts newline to current buffer at current cursor position
	function = {
		bf_d[modified]=1
		save-state
		buffer=('' "${buffer[@]:1:${bf_d[line]}-1}" '' "${buffer[@]:${bf_d[line]}}")
		buffer[bf_d[line]]="${buffer[${bf_d[line]}+1]:0:${bf_d[column]}}"
		buffer[bf_d[line]+1]="${buffer[${bf_d[line]}+1]:${bf_d[column]}:${#buffer[${bf_d[line]}+1]}}"
		bf_d[column]=0
		syntax-shift
		no_cursor=1
		redraw
		no_cursor=0
		next-line
	}

defun syntax-shift
	:: Moves syntax multibuffer from current cursor position one line to the bottom
	:: Used in newline function
	function = {
		local -a tmp1
		local -a tmp2
		local extmp1
		local extmp2
		for ((l=bf_d[line];l<${#buffer[@]}+1;l++)); do
			local -n linearray="${current_buffer}_syntax${l}"
			copy-array linearray tmp1
			copy-array tmp2 linearray
			copy-array tmp1 tmp2
			extmp1="${bf_e[l]}"
			bf_e[l]="$extmp2"
			extmp2="$extmp1"
		done
		bf_s[buffer_length]="${current_buffer}_syntax${bf_d[number-length]}"
		unset tmp1 tmp2
		make-render-area $((bf_d[line])) $((bf_d[line]+2))
	}

defun delete-line
	:: Deletes line at current cursor position
	function = {
		bf_d[modified]=1
		buffer-delete-line "${bf_d[line]}"
		((bf_d[line] == 1)) || previous-line
		redraw
	}

defun buffer-delete-line
	:: Deletes line at \$1
	function = {
		local -i l=$1
		save-state
		buffer=("" "${buffer[@]:1:l-1}" "${buffer[@]:l+1}")
		bf_s=("" "${bf_s[@]:1:l-1}")
	}

fragment getrlr <<'+'
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
+

fragment predelete <<'+'
	((bf_d[selection])) && {
		delete-selection
		return
	}
	((${#buffer[${bf_d[line]}]} == 0 )) && {
		delete-line
		bf_d[column]="${#buffer[${bf_d[line]}]}"
		redraw
		return 0
	}
+

defun-fragment backspace
	:: Deletes previous character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==0)) && {
			buffer[bf_d[line]-1]="${buffer[bf_d[line]-1]}${buffer[bf_d[line]]}"
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[${bf_d[line]}]="${buffer[${bf_d[line]}]:0:$(( rlr - 1 ))}${buffer[${bf_d[line]}]:${rlr}}"
		backward-char #go back with cursor
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun-fragment delete
	:: Deletes next character
	function = {
		save-state
		@ predelete
		@ getrlr
		((rlr==${#buffer[bf_d[line]]})) && {
			buffer[bf_d[line]]="${buffer[bf_d[line]]}${buffer[bf_d[line]+1]}"
			move-next-line
			delete-line
			bf_d[column]=${#bf_e[${bf_d[line]}]}
			redraw
			return 0
		}
		buffer[bf_d[line]]="${buffer[bf_d[line]]:0:rlr}${buffer[bf_d[line]]:rlr+1:${#buffer[bf_d[line]]}}"
		make-render-line # copy the buffer into bf_s and bf_e
		redraw #draw it
		bf_d[modified]=1
	}

defun delete-selection
	:: Deletes region
	function = {
		_ sy bf_d[selection_start_y]
		_ ey bf_d[selection_end_y]
		_ sx bf_d[selection_start_x]
		_ ex bf_d[selection_end_x]
		((sy == ey)) && {
			((sx > ex)) && __ sx ex
			buffer[sy]="${buffer[sy]:0:sx}${buffer[sy]:ex}"
			bf_d[column]=$sx
			make-render-area $sy $((sy+1))
		} || {
			((sy > ey)) && {
				__ sy ey
				__ sx ex
			}
			buffer[sy]="${buffer[sy]:0:sx}"
			buffer[ey]="${buffer[ey]:ex}"
			buffer=("" "${buffer[@]:1:sy}" "${buffer[@]:ey}")
			bf_s=("" "${bf_s[@]:1:sy-1}")
			buffer[sy+1]="${buffer[sy]}${buffer[sy+1]}"
			buffer=("" "${buffer[@]:1:sy-2}" "${buffer[@]:sy}")
			bf_d[line]=$sy
			bf_d[column]=$sx
		}
		bf_d[selection]=0
		redraw
		_ # unset reference aliases
	}

defun write-buffer
	:: Writes current buffer into its target file	
	function =
		if [ -w "${bf_d[file]}" ]; then
			dump-buffer "${bf_d[file]}"
			bf_d[modified]=0
			message="Wrote ${#buffer[@]} lines to \'${bf_d[file]}\'"
		else
			return 1
		fi

defun dump-buffer
	:: Dumps current buffer into a file	
	function = {
			true >"$1" # Set the file to an empty text file
			for ln in "${buffer[@]}"; do # Write in the buffer to the file
				echo "$ln" >>"$1"
			done
	}
  
add-mode quit
	local-set-key "$(kbd y)" 'save-quit'
	local-set-key "$(kbd n)" 'die'
	local-set-key "$(kbd c)" 'quit-quit'
	local-set-key "$(kbd C-y)" 'save-quit-force'

defun save-quit-force
	:: Force saving file
	function = {
		dump-buffer "${bf_d[file]}"
		die
	}
	
defun save-quit
	:: Writes buffer if target is writable
	function =
		if write-buffer; then
			die
		else
			message='File is not writable! [n/c] (to force save C-y)'
			redraw-commandline
		fi

defun quit-quit
	:: Quits quit message
	function = {
		bf_d[mode]="$bckmode"
		message='Quit canceled'
		redraw
	}

defun quit
	:: Displays quit message and sets mode to \'quit\'
	function =
		if ((bf_d[modified])); then
			[ -z "$bckmode" ] && bckmode="${bf_d[mode]}"
			bf_d[mode]='quit'
			redraw-statusline
			printf '\e[%s;0H' $((bf_d[size-y] + bf_d[loc-y]))
			printf '%s' 'Buffer modified, save before close? [y/n/c]'
		else
			die
		fi

defun die
	:: Closes Ebashs with exit code \$errno, if errno is empty exit with 0
	:: If \$nocleanup is 1, do not restore the terminal to sane mode and do not cleanup 
	:: Else restore to sane mode 
	function = {
		((nocleanup)) && exit "${errno:-0}"
		echo -e "\e[?1000;1006;1015l" #disable mouse tracking
		clear-screen # TODO fix the buffer switching
		printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
		exit "${errno:-0}" # Assume that we are exiting without an error
	}

defun abort
	:: Sets \$nocleanup to 1 and dies	
	function = {
		((nocleanup=1)) && die "$@"
	}

fragment move <<< 'for ((i = 0; i < ${1:-1}; i++)); do'
fragment end <<< 'done'

fragment keepcolumn <<'+'
	[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
	(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
	(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
+

defun-fragment move-previous-line
	:: Moves up \$1 lines, if \$ is empty move up 1 line
	function = {
		@ move
			((bf_d[line] > 1)) && ((bf_d[line]--)) # As long as we can keep going up, go up
			((bf_d[line] < bf_d[base] + 1)) && {
				((bf_d[base]--)) # Push back the top if we need to
				move_base=1 # Send signal to redraw-cursor that the buffer was moved, thus needs to be redraw fully
				((bf_d[base] <= 0)) && bf_d[base]=1 # Don't push back if our base is at 1
			}
			@ keepcolumn
		@ end
	}

defun-fragment move-next-line
	:: Moves down \$1 lines, if \$ is empty move down 1 line
	function = {
		@ move
			((bf_d[line] < ${#buffer[@]}+1)) && ((bf_d[line]++)) # If we can go down, go down
			# Move window down if needed
			((bf_d[line] > bf_d[base] + bf_d[size-y] - 3 - bottomlines)) && {
				((bf_d[base]++))
				move_base=1
			}
			@ keepcolumn
		@ end
}

template move <<<'function @var 1 { @var 2 @var 3 ; redraw-statusline; redraw-cursor; }'
	@: previous-line move-previous-line '$@'
	@: next-line move-next-line '$@'
	@: scroll-down move-previous-line '$((bf_d[size-y] - 3))'
	@: scroll-up move-next-line '$((bf_d[size-y] - 3))'

@fn move-beginning-of-line 'bf_d[column]=0; redraw'
@fn move-end-of-line 'bf_d[column]="${#bf_e[${bf_d[line]}]}"; redraw'

fragment select <<'+'
    ((bf_d[selection])) || {
		bf_d[selection_start_y]="${bf_d[line]}"
		bf_d[selection_start_x]="${bf_d[column]}"
		bf_d[selection]=1
	}
+
template select <<<'function @var 1 { @ select; @var 2 ; } && @add @var 1'
	@: select-forward forward-char
	@: select-backward backward-char
	@: select-next next-line
	@: select-previous previous-line

fragment forwardcheck <<'+'
	((bf_d[column] > ${#bf_e[${bf_d[line]}]})) && {
		bf_d[column]=0
		next-line
		return
	 }
+
fragment backwardcheck <<'+'
	((bf_d[column] < 0)) && ((bf_d[line]==1)) && {
		bf_d[line]=1
		bf_d[column]=0
	}
	((bf_d[column] < 0)) && {
		bf_d[column]="${#bf_e[${bf_d[line]}-1]}"
		previous-line
		return
	}
+

template char <<'+'
	function @var 1 {
		@ move ;
			case "${bf_e[${bf_d[line]}]:${bf_d[column]} @var 2 1:1}" in
				't') bf_d[column]=$(( bf_d[column] @var 2 ${#options[tabchar]}));;
				*) ((bf_d[column] @var 3 ));;
			esac; @var 4 ; bckrl= ;
		@ end ;
		if ((bf_d[selection])); then
			redraw ;
		else
			redraw-cursor-line ;
		fi ;
	} && @add @var 1 ;
+
	@: forward-char + ++ '@ forwardcheck'
	@: backward-char - -- '@ backwardcheck'

fragment charbreak <<'+'
	case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
		't'|'s') break;;
	esac
+

defun-fragment forward-word
	:: Moves forward to next word
	function = {
		((bf_d[column] == ${#bf_e[bf_d[line]]})) && {
			next-line
			move-beginning-of-line
		}
		while :; do
			((bf_d[column] < ${#bf_e[bf_d[line]]})) && ((bf_d[column]++)) || break
			@ charbreak
		done
		redraw
	}

defun-fragment backward-word
	:: Moves backward to previous word
	function = {
		((bf_d[column] == 0)) && {
			previous-line
			move-end-of-line
		}
		while :; do
			((bf_d[column] > 0)) && ((bf_d[column]--)) || break
			@ charbreak
		done
		redraw
	}

defun set-mark-command
	:: Begins selection	
	function =
		if ((bf_d[selection])); then
			log info 'selection disable'
			bf_d[selection]=0
		else
			bf_d[selection]=1
			bf_d[selection_start_y]="${bf_d[line]}"
			bf_d[selection_start_x]="${bf_d[column]}"
			log info 'selection enable'
		fi

defun shell
	:: Spawns bash as subprocess
	function = {
		clear-screen
		bash # NOTE: in theory an external command
		redraw
	}

defun execute
	:: Executes a command and inserts its output into buffer	
	function = {
		((bf_d[line] == 0)) && return # If the line is not possible, do nothing
		printf '\e[?25h\e[%sH' "$((bf_d[line] + 2 - bf_d[base]))" # Reset cursor position and enable cursor
		read -re -p "$(printf '%4s ' "$")" # Present editable line
		if [[ "$REPLY" != "${buffer[${bf_d[line]}]}" ]]; then # If the line is changed, update and inform
			buffer[${bf_d[line]}]="$($REPLY)"
			bf_d[modified]=1
		fi
		make-render-line
		redraw
	}

defun diff-buffer-syntax
	:: Deletes highlighting on modified lines, comparing two buffers
	function = {
		# remove outdated lines from bf_s to set them for resyntaxing
		local -n source="$1"
		local -n target="$2"
		for idx in "${!target[@]}"; do
			[ "${source[idx]}" = "${target[idx]}" ] || bf_s[idx]=
		done
	}

defun diff-buffer-copy
	:: Compares two buffers and copies the difference into \$3 buffer
	function = {
		local -n source="$1"
		local -n check="$2"
		local -n target="$3"
		[ -z "${source[*]}" ] && return 1 # | indicate that there's no previous buffer state to check against 
		[ -z "${check[*]}"  ] && return 1 # | should indicate save-state() to just copy the whole buffer
		target=()
		for idx in "${!source[@]}"; do
			[ "${source[idx]}" = "${check[idx]}" ] || target[idx]="${source[idx]}"
			[ "${source[idx]}" = "${check[idx]}" ] && target[idx]=''
		done
	}

defun diff-buffer-merge
	:: Add buffer \$1 on top of \$2
	function = {
		local -n source="$1"
		local -n target="$2"
		for idx in "${!source[@]}"; do
			[ -n "${source[idx]}" ] && target[idx]="${source[idx]}"
		done
	}

defun save-state
	:: Saves current buffer for undo function
	function = {
		((bf_d[current_state]++))
		declare -ga "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-copy\
			buffer\
			"${current_buffer}_buffer_state_$((bf_d[current_state]-1))"\
			"${current_buffer}_buffer_state_${bf_d[current_state]}" || {
			copy-array buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		}
	}

defun undo
	:: Undo a change
	function = {
		((bf_d[current_state]--))
		((bf_d[current_state]<0)) && {
			bf_d[current_state]=0
			bf_d[modified]=0
		}
		diff-buffer-syntax buffer "${current_buffer}_buffer_state_${bf_d[current_state]}"
		diff-buffer-merge "${current_buffer}_buffer_state_${bf_d[current_state]}" buffer
		redraw
	}

defun toggle-mouse
	:: 'Changes options[mouse]'
	function =
		case "${options[mouse]}" in
			0)
				printf '\e[?1000;1006;1015h'
				options[mouse]=1
				message='Enabled options[mouse]';;
			1)
				printf '\e[?1000;1006;1015l'
				options[mouse]=0
				message='Disabled options[mouse]'
		esac

defun toggle-mode-line
	:: 'Changes options[mode-line]'
	function =
		case "${options[mode-line]}" in
			0)
				options[mode-line]=1
				((bottomlines++))
				redraw;;
			1)
				options[mode-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-command-line
	:: 'Changes options[command-line]'
	function =
		case "${options[command-line]}" in
			0)
				options[commandline]=1
				((bottomlines++))
				redraw;;
			1)
				options[command-line]=0
				((bottomlines--))
				redraw
		esac

defun toggle-line-number-mode
	:: 'Changes options[line-number-mode]'
	function = {
		case "${options[line-number-mode]}" in
			0) options[line-number-mode]=1;;
			1) options[line-number-mode]=0
		esac
		redraw
	}

defun toggle-menu-line
	:: 'Changes options[menu-line]'
	function = {
		case "${options[menu-line]}" in
			0) options[menu-line]=1;;
			1) options[menu-line]=0
		esac
		toplines="${options[menu-line]}"
		redraw
	}
		
defun menuline-mouse
	:: Handle clicking on top menu with mouse		
	function = {
		local -n top_0="menu_${bf_d[menuline]}_0"
		local -n top_1="menu_${bf_d[menuline]}_1"
		#determine which item should be triggered
		[ -z "$1" ] && menuloc_x=0 || menuloc_x=$1
		local cx="${bf_d[loc-x]}"
		i=0
		for i in "${!top_0[@]}"; {
			la="${#top_0[i]}"
			((menuloc_x>cx)) && ((menuloc_x<(cx + la + 1))) && {
				${top_1[$i]}
				return
			}
			cx=$(( cx + la + 1 ))
		}
	}

defun redraw-menu
	:: Redraw popup menu
	function = {
		printf '\e[?25l' # hide cursor (again)
		printf '\e[%s;0H' $menuloc_y
		for i in "${!menu_0[@]}"; {
			if ((i == menuselection)); then
				printf "\e[%sC${faces[menu-selected-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"  
			else
	   			printf "\e[%sC${faces[menu-enabled-face]}%s${reset}\n" $menuloc_x "${menu_0[i]}"
			fi
		}
	}
template menumove <<'+'
	function @var 1 {
		((menuselection @var 2 @var 3 )) && ((menuselection @var 4 ));
		redraw-menu;
	}
+
@: menuup '>' 0 '--'
@: menudown '<' '${#menu_0[@]} -1' '++'

defun menuselect
	:: Execute selected item in menu
	function =
		for i in "${!menu_1[@]}"; {
			((i == menuselection)) && "${menu_1[i]}"
		}

defun menuleave
	:: Closes a menu
	function = {
		ismenu=0
		bf_d[mode]="${modebackup}"
		redraw
	}

defun menu
	:: Opens a menu \$1	
	function = {
		declare -ng menu_0=menu_${1}_0
		declare -ng menu_1=menu_${1}_1
		((ismenu == 0 )) && modebackup="${bf_d[mode]}"
		ismenu=1
		declare -ig menuselection=0
		bf_d[mode]='menu'
		redraw
	}

defun delete-buffer
	:: deletes current buffer
	function = {
		local -a copy
		local i=0
		local index
		for b in "${buffers_l[@]}"
		do
			[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
			[[ "$b" = "$current_buffer"  ]] && index="$i"
			((i++))
		done
		unset buffers_l
		copy-array copy buffers_l
		current_buffer="${buffers_l[index-1]}"
		redraw
	}

fragment printarg <<'+'
	"${bf_d[loc-x]}"\
	"${bf_d[size-x]}"\
	''\
	"${bf_d[loc-x]}"\
	"$i"\
	"${faces[default]}"\
+

fragment printargnonl <<'+'
	"${bf_d[loc-x]}"\
	"${bf_d[size-x]}"\
	''\
	"${bf_d[loc-x]}"\
	"${faces[default]}"\
+

defun print-line-number
	:: Print line number of line \$i
	function = {
		((options[line-number-mode])) && {
			printf '%b' "${faces[line-number]}"
			((i == bf_d[line])) &&
				printf '%b' "${faces[line-number-current-line]}" # Highlight line line-number if selected
		}
		((i > ${#buffer[@]})) &&
			printf '\e[%sG%b%*s%s%b%*s%b'\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-empty]}"\
				   $((bf_d[number-length]/2)) ''\
				   "${options[empty-line-char]}"\
				   "${faces[default]}"\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				   "$nlchar"
	}


defun-fragment selection-draw
	:: Draw multiline region
	function =
		if ((options[line-number-mode])); then
			if ((i == bf_d["${1}_y"])); then
				printf "\e[%sG%*s\e[%sG%${bf_d[number-length]}s %b%s%b%s%b%b"\
					   @ printarg\
					   "${linearray[*]:bf_d[basecolumn]:bf_d[${1}_x]}"\
					   "\e[m${faces[region]}"\
					   "${buffer[i]:bf_d[${1}_x]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
					   "${faces[default]}" "$nlchar"
			elif ((i == bf_d["${2}_y"])); then
				printf "\e[%sG%*s\e[%sG%${bf_d[number-length]}s %b%b%s%b%s%b%b"\
					   @ printarg\
					   "${faces[region]}"\
					   "${buffer[i]:bf_d[basecolumn]:bf_d[${2}_x]}"\
					   "\e[m"\
					   "${linearray[*]:bf_d[${2}_x]:bf_d[size-x]}"\
					   "${faces[default]}" "$nlchar"
			else
				printf "\e[%sG%*s\e[%sG%${bf_d[number-length]}s %b%b%s%b%b"\
					   @ printarg\
					   "${faces[region]}" "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
					   "${faces[default]}" "$nlchar"
			fi
		else
			if ((i == bf_d["${1}_y"])); then
				printf "\e[%sG%*s\e[%sG%b%s%b%s%b%b"\
					   @ printargnonl\
					   "${linearray[*]:bf_d[basecolumn]:bf_d[${1}_x]}"\
					   "\e[m${faces[region]}"\
					   "${buffer[i]:bf_d[${1}_x]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
					   "${faces[default]}" "$nlchar"
			elif ((i == bf_d["${2}_y"])); then
				printf "\e[%sG%*s\e[%sG%b%b%s%b%s%b%b"\
					   @ printargnonl
					   "${faces[region]}"\
					   "${buffer[i]:bf_d[basecolumn]:bf_d[${2}_x]}"\
					   "\e[m"\
					   "${linearray[*]:bf_d[${2}_x]:bf_d[size-x]}"\
					   "${faces[default]}" "$nlchar"
			else
				printf "\e[%sG%*s\e[%sG%b%b%s%b%b"\
					   @ printargnonl\
					   "${faces[region]}" "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
					   "${faces[default]}" "$nlchar"
			fi
		fi

defun change-size-screen
	:: Handle changing size of terminal
	function = {
		bf_d[size-x]="$COLUMNS"
		bf_d[size-y]=$((LINES-1))
		redraw
	}

defun redraw
	:: Redraw screen
	function = {
		[ -n "${bf_d[redraw]}" ] && {
			"${bf_d[redraw]}" "$@"
			return
		}
		printf '\e[?25l'

		# the first line should be always empty 
		unset buffer[0]
		
		# Handle changing size of buffer
		((bf_d[size-x]!=bcksize_x)) || ((bf_d[size-y]!=bcksize_y)) && {
			# Make the statusline full of dashes
			dashline=$(
				for ((i=0; i<bf_d[size-x]; i++)) {
					printf '-'
				}
					)
			bcksize_x=${bf_d[size-x]}
			bcksize_y=${bf_d[size-y]}
		}
		
		# Get length of line-number of lines
		bf_d[length]="${#buffer[@]}"
		((bf_d[length]==0)) &&((bf_d[length]++))
		
		((options[line-number-mode])) && {
			bf_d[number-length]=${#bf_d[length]}
			bf_d[number-space]=1
		} || ((bf_d[number-length]=0, bf_d[number-space]=0))
		
		# Update selection ends to current cursor
		((bf_d[selection]==1)) &&
			((bf_d[selection_end_y]=bf_d[line], bf_d[selection_end_x]=bf_d[column]))
		
		# Move the buffer horizontally if needed
		((bf_d[column] +3 < bf_d[size-x] - bf_d[number-length] - 1)) &&
			bf_d[basecolumn]=0
		((bf_d[column] +3 > bf_d[size-x] - bf_d[number-length] - 1)) &&
			bf_d[basecolumn]=$((bf_d[column] - (bf_d[size-x] + bf_d[loc-x] - bf_d[number-length] - 1) +3))

		# Draw top menuline
		(("${options[menu-line]}"==1)) && {
			local -n top_0="menu_${bf_d[menuline]}_0"
			printf "\e[0m\e[%s;%sH${faces[menu]}\e[?25l%*s\r%s"\
				   "${bf_d[loc-y]}"\
				   "${bf_d[loc-x]}"\
				   "${bf_d[size-x]}"\
				   "${bf_d[info]}"
			printf '\e[%sG%s\e[0m\n' "${bf_d[loc-x]}" "${top_0[*]}"
		} || printf "\e[%s;%sH" "${bf_d[loc-y]}" "${bf_d[loc-x]}"

		# IFS has to be empty in order to bufferarray multiarray be printed as words instead of chars
		IFS=''
		
		# Iterate over shown lines
		local -i max=$((bf_d[size-y] - (toplines + bottomlines) + 1))
		((bf_d[raw])) &&
			# The raw rendering is just dirty hack to get better perfomance in buffer which don't need fancy effects
			# Will be removed once normal rendering is fast enough (or rather if it'll ever be
			{
				for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do
					((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'
					
					print-line-number
					((i > ${#buffer[@]})) || {
						if ((options[line-number-mode])); then
							printf "\e[%sG%*s\e[%sG%${bf_d[number-length]}s %b%s%b"\
								   @ printarg\
								   "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
								   "$nlchar"
						else
							printf "\e[%sG%*s\e[%sG%b%s%b"\
								   @ printargnonl\
								   "${buffer[i]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
								   "$nlchar"
						fi
					}
				done
			} || {
				for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do

					# if the line is last, do not add newline
					((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'
					
					print-line-number

					((i > ${#buffer[@]})) && continue
					
					# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
					[ -z "${bf_s[bf_d[base]+bf_d[size-y]-(bottomlines+toplines)+2]}" ] && {
						bottomest=$((bf_d[base]+bf_d[size-y]-(bottomlines+toplines)+2))
						make-render-area $bottomest $((bottomest+options[render-chunk]))
					}
					[ -z "${bf_s[i]}" ] && {
						make-render-area $((base + i)) $((base + i + 1)) # idk why make-render-line doesnt work here
					}
					local -n linearray="${bf_s[i]}"
					
					# draw the selection area
					((bf_d[selection])) && {
						((i == bf_d[selection_start_y])) &&
							((bf_d[selection_start_y] == bf_d[selection_end_y])) && {
								((bf_d[selection_start_x] <= bf_d[selection_end_x])) && {
									local -n sx=bf_d[selection_start_x]
									local -n ex=bf_d[selection_end_x]
								} || {
									local -n sx=bf_d[selection_end_x]
									local -n ex=bf_d[selection_start_x]
								}
								if ((options[line-number-mode])); then
									printf "\e[%sG%*s\e[%sG%${bf_d[number-length]}s %b%s%b%s%b%s%b"\
										   @ printarg\
										   "${linearray[*]:bf_d[basecolumn]:sx}"\
										   "\e[m${faces[region]}"\
										   "${buffer[i]:sx:ex-sx}"\
										   "\e[m"\
										   "${linearray[*]:ex:bf_d[size-x]}"\
										   "$nlchar"
								else
									printf '\e[%sG%*s\e[%sG%b%s%b%s%b%s%b'\
										   @ printargnonl\
										   "${linearray[*]:bf_d[basecolumn]:sx}"\
										   "\e[m${faces[region]}"\
										   "${buffer[i]:sx:ex-sx}"\
										   "\e[m"\
										   "${linearray[*]:ex:bf_d[size-x]}"\
										   "$nlchar"
								fi
								continue
							}
						((i >= bf_d[selection_start_y])) && ((i <= bf_d[selection_end_y])) && {
							selection-draw selection_start selection_end
							continue
						}
						((i <= bf_d[selection_start_y])) && ((i >= bf_d[selection_end_y])) && {
							selection-draw selection_end selection_start
							continue
						}
					}
					# due to escape codes present in bf_s,
					# the bf_s has to be multidimensional nonsense for perfomance reasons

					#I would make this less repeated, but the line has to be printed by single printf to stop flickering, so bloat has to be
					if ((options[line-number-mode])); then
						printf "\e[%sG%*s\e[%sG%${bf_d[number-length]}s %b%s%b"\
							   @ printarg\
							   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
							   "$nlchar"
					else
						printf "\e[%sG%*s\e[%sG%b%s%b"\
							   @ printargnonl\
							   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length] + 1)}"\
							   "$nlchar"
					fi
				done
			}
		
		redraw-statusline
		redraw-commandline
		((no_cursor)) || redraw-cursor
		
		@ifs
		
		# redraw menu if open
		[ "${bf_d[mode]}" = 'menu' ] && redraw-menu
	}

defun redraw-cursor-line
	:: Draw cursor on the line
	function = {
		printf '\e[%sG\e[?25h'\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
	}
	
defun redraw-cursor
	:: Draw cursor and if move_base is 1 redraw
	function = {
		((options[full-redraw])) && {
			no_cursor=1
			redraw
			no_cursor=0
		}
		((move_base)) && {
			move_base=0
			redraw
			return
		}
		local -i y=$((bf_d[line] + options[menu-line] - bf_d[base] + bf_d[loc-y]))
		((options[line-number-mode])) && {
			printf '\e[%s;%sH%b%*s\e[m'\
				   $((last_line + options[menu-line] - bf_d[base] + bf_d[loc-y]))\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number]}"\
				   ${bf_d[number-length]}\
				   $last_line
			printf '\e[%s;%sH%b%*s\e[m'\
				   $y\
				   "${bf_d[loc-x]}"\
				   "${faces[line-number-current-line]}"\
				   ${bf_d[number-length]}\
				   ${bf_d[line]}
		}
		printf '\e[%s;%sH\e[?25h'\
			   $y\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
		last_line=${bf_d[line]}
	}

defun redraw-statusline
	:: Draw bottom mode/status line
	function = {
		((options[mode-line])) &&
			printf "\e[%s;%sH\e[%sG%b%s\e[%sG%s %b%s\e[m%b %d%% (%d,%d) (%s[%s]) (screen: %s) \e[m" \
				   $((bf_d[size-y] - 1 + bf_d[loc-y]))\
				   $((bf_d[size-x] + bf_d[loc-x]))\
				   "${bf_d[loc-x]}"\
				   "${faces[mode-line]}"\
				   "$dashline"\
				   "${bf_d[loc-x]}" \
				   "${bf_d[mode]}"\
				   "${faces[file-name]}"\
				   "$(base-name "${bf_d[file]}")"\
				   "${faces[mode-line]}"\
				   $((100 * bf_d[line] / bf_d[length]))\
				   "${bf_d[line]}"\
				   "${bf_d[column]}"\
				   "${highlight[${bf_d[filetype]}]}"\
				   "${bf_d[filetype]}"\
				   "$current_buffer"
	}

defun redraw-commandline
	:: Draw bottomest command line message echo area
	function = {
		# clear message if it has been printed before already
		((options[keep-message]==0)) && 
			((clrmsg)) && {
				message=
				clrmsg=0
			} || clrmsg=1
		if ((options[command-line])); then
			printf "\e[%s;%sH\n${faces[minibuffer-prompt]}%*s\r%s\e[m" \
				   $((LINES-1)) 1 $((COLUMNS)) ' ' "$message"
		else
			[ -n "$message" ] &&
				printf "\e[%s;%sH%s" \
					   $((LINES)) 1 "$message"
		fi
	}

defun-fragment insert-word
	:: Insert \$1 to buffer
	function = {
		save-state
		@ getrlr
		buffer[bf_d[line]]="${buffer[${bf_d[line]}]:0:${rlr}}$1${buffer[${bf_d[line]}]:${rlr}}"\
			  #add at cursor position - amount of tabs * tab size
			  ((bf_d[raw])) || make-render-line
		forward-char "${#1}"
		bf_d[selection]=0
		redraw
		bf_d[modified]=1
	}
	
@fn self-insert 'insert-word $@'
@fn insert-space 'insert-word " "'
@fn indent-for-tab-command "insert-word '	'"

defun handle-mouse
	:: Handle mouse click
	function = {
		local -i x y
		#parse mouse stuff somewhatish weirdly
		[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
		[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
		[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
		[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
		((skipnext==1)) && skipnext=0 && return
		((skipnext==0)) && [ "${k_hex[*]:0:2}" = '1b 5b' ] && {
			mapfile -t -d '' inputarray <<< "${1}"
			inputarray[-1]="${inputarray[-1]%?}"
			[ -z "${inputarray[2]}" ] && skipnext=1
			mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
			inputarray[-1]="${inputarray[-1]%?}"	
			mousemode="${inputarray[0]}"
			x="${inputarray[1]}"
			y="${inputarray[2]::-1}"
			#limitations of movenment
			#TODO:
			[ $y = "${bf_d[loc-y]}" ] && menuline-mouse $x && return #handle menuline
			((x < (bf_d[number-length] + bf_d[loc-x] + 2))) && {
				if [ "$mousemode" = '[<0' ]; then
					bf_d[line]=$(( bf_d[base] + ( (y - bf_d[loc-y]) - toplines) ))
					redraw
				elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
					clear-screen
					echo 'Enter the index: '
					read -re line
					redraw
				fi
				return
			}
			bf_d[line]=$(( bf_d[base] + ( y - bf_d[loc-y] - 1) ))
			bf_d[column]=$(( x - (bf_d[loc-x] + bf_d[number-length] + 1) ))
			((bf_d[line] > ${#bf_e[@]})) &&
				bf_d[line]=${#bf_e[@]}
			((bf_d[column] > ${#bf_e[bf_d[line]]})) &&
				bf_d[column]=${#bf_e[bf_d[line]]}
			redraw
		}
	}
nufed
	
@@ input-key Handles input
:: Either \$1 raw character input or k_hex array containing hex values of characters is used
function input-key {
	#arg $1 is the pressed key in normal text form
	#k_hex is pressed key in hex array ending with 0
		
	local -i mode_contains=0
	local -n modekeys="keys_${bf_d[mode]}"\
	         key_options="key_options_${bf_d[mode]}"

	# global keys
	((key_options[disable-global])) ||
		for str in "${!keys_global[@]}"
		{
			[ "$str" = "${k_hex[*]}" ] && {
				"${keys_global[$str]}"
				return
			}
		}

	# Execute the 'always' key option
	((${#key_options[@]})) &&
		[ -n "${key_options[always]}" ] && "${key_options[always]}"

	# Loop over current mode keybindings to match current keypress
	for str in "${!modekeys[@]}"
	{
		[ "$str" = "${k_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	}

	# If mode keybinding doesn't contain current keypress, execute this
	((${#key_options[@]})) &&
		((mode_contains == 0)) &&
		[ -n "${key_options[else]}" ] && {
			[ "${key_options[else]}" = 'insert' ] || {
				"${key_options[else]}" && return
			}
		}

	# Do not continue if mode contains keypress to prevent control chars flooding file
	((mode_contains==1)) && return

	# If mouse is enabled, do whatever the hell that ugly piece of code does
	(("${options[mouse]}"==1)) && {
		handle-mouse "$1"
		return
	}

	# Insert the pressed character
	[[ $1 =~ [[:cntrl:]] ]] && return # If char is control char, return
	insert-word "$1"
}

@@ main Main keyboard loop
function main
	while :; do
		local -a k=()
		local -i i=1
		k_hex=() # Also convert the input sequence into hex for way easier handling
		# Check for ready input
		read -rsN1 k[0] && {
			k_hex[0]="$(printf "%x\n" "'${k[0]}")"
			# Multibyte hack
			while read -rsN1 -t0.0001 k[$i]; do
				k_hex[$i]="$(printf "%x\n" "'${k[$i]}")"
				((i++))
			done
			k_hex[$i]='0'
			input-key "${k[@]}" # Handle keypress event
		}
	done


@@ load-config Sources custom config file
function load-config {
	log_buffer+=('LOADING CONFIG...')
	local config_file
	local f
	f=~/.config/ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=~/.config/ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=~/.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc ;[ -f "$f" ] && config_file="$f"
	f=.ebashsrc.d/init.bash ;[ -f "$f" ] && config_file="$f"
	
	f="${EBASHS_CONFIG}" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	f="${EBASHS_CONFIG_DIR}/init.bash" ;[ -n "$f" ] && [ -f "$f" ] && config_file="$f"
	
	[ -z "$config_file" ] && return
	source "$config_file"
	log_buffer+=("LOADED $config_file")
}
	
@@ init
:: Prepares variables and launches main function
function init {
	case "$1" in
		'--quick'|'-Q')
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config
			shift;;
		'--version')
			echo "$version"
			abort;;
		'--dump')
			declare -f
			abort;;
		'--help')
			print-stdin <<EOF
Usage: ebashs [OPTION-OR-FILENAME]...

Run Ebashs, the extensible, customizable, maybe-real-time
display editor.  The recommended way to start Ebashs for normal editing
is with no options at all.

Run C-h r RET inside Ebashs to read "manual".

Initialization options:
--quick, -Q    don't load config
--help,        display this help and exit
--version,     display version information and exit
EOF
			abort;;
		*)
			log_buffer+=('- LOAD DEFAULT CONFIG -')
			load-default-config #loads default config
			load-config
	esac
	((options[log])) && init-log || unset buffer_log # set up log buffer (M-x log)
	
	log info setting traps...
	trap change-size-screen WINCH ALRM # Attach WINCH and ALRM to redraw the screen
	trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
	trap 'k_hex=(3 0); input-key' INT
	trap quit SIGTERM

	
	menuloc_y=0; menuloc_x=0 # menu positions
	log info 'Setting menu-line'
	toplines=${toplines:-0}
	toplines="${options[menu-line]}"

	# this is reverse because the value is added to buffer redrawing size
	log info 'Setting mode-line'
	bottomlines=${bottomlines:-0}
	((options[mode-line]==0)) && ((bottomlines--))
	log info 'Setting command-line'
	((options[command-line]==0)) && ((bottomlines--))
	((bottomlines+=2))
	
	log-echo "toplines $toplines"
	log-echo "bottomlines $bottomlines"
	
	log info 'Setting reset'
	reset='\e[0;0m'
	log info 'Setting charmap'
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	log info 'Setting nlchar'
	nlchar='\n'
	printf '\e[?1049h'
	log info 'Setting mouse'
	(("${options[mouse]}")) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking

	
	if [[ "$1" ]]; then # If a file was provided in the terminal pre-load it
		log info "args: $1"
		if [ -d "$1" ]; then
			log info "[$1] is directory => dired"
			cd "$1" || exit
			dired # enter the file selector in specified folder
		else
			log info "[$1] is file => read-buffer"
			read-buffer "$1"
		fi
	else
		log info "no arg => dired"
		dired # enter the file selector
	fi
	log info "drawing..."
	redraw
	log info 'entering main loop...'
	main
}

log_buffer+=('INIT')
init "$@"
